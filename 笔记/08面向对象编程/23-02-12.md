关键字 封装 继承 super 重写/覆盖Override 多态

封装(encapsulation)
  介绍
    封装(encapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起,数据被保护在内部,程序的其它部分只有通过被授权的操作[方法],才能对数据进行操作。
  优点
    1)隐藏实现细节
    2)可以对数据进行验证，保证安全合理
  实现
    1)将属性进行私有化[不能直接修改属性]
    2)提供一个公共的set方法,用于对属性判断并赋值
    3)提供一个公共的get方法,用于获取属性的值

对参数的封装 传入一个实体类

继承
  介绍
    继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。
  继承的基本语法
    class子类extends父类{}
  概念
    1)子类就会自动拥有父类定义的属性和方法
    2)父类又叫超类，基类。
    3)子类又叫派生类。
  细节
    1.子类继承了所有的属性和方法，非私有的属性和方法可以直接访问，但是私有属性和方法[不能在子类直接访问]，要通过[父类提供的公共方法]去访问
    2.子类必须调用[父类的无参构造器],完成父类的初始化，且父类的无参构造器必须有，子类调用构造器会隐藏了一句[super();]
    3.当创建子类对象时，[不管使用子类的哪个构造器]，[默认情况]下总会去调用父类的[无参构造器]，如果[父类没有提供无参构造器]，则必须在[子类的构造器]中用[super]去[指定使用父类的哪个构造器]完成对父类的初始化工作，否则，编译不会通过[举例说明]
    4.如果希望指定去调用父类的某个构造器，则显式的调用一下,[super(参数列表);]
    5.super在使用时,[必须放在构造器第一行]
    6.[super()和this()]都只能放在构造器第一行，因此这[两个方法不能共存在一个构造器]，如果使用this(),则被调用的构造器同样会执行super()
    7.java所有类都是Object类的子类
    8.父类构造器的调用不限于直接父类!将一直往上追溯直到Object类(顶级父类)
    9.子类最多只能继承一个父类(指直接继承)，即java中是[单继承机制]。但可以多层继承达到多继承的形式
    10.不能滥用继承，子类和父类之间必须满足is-a的逻辑关系
  [本质]内存情况
    1.在new的时候会逐层查找父类，由[上到下逐一加载类信息],Object>Father>Son
    2.堆开辟一块空间，被加载类的信息会从上到下存放入该空间，相同名称不冲突
    3.该空间被son指向
    4.输出属性时会按照从子类到父类向上查找且输出最近的属性值

super
  介绍
    super代表父类的引用，用于访问父类的属性、方法、构造器
  基本语法
    1.访问父类的属性，但不能访问父类的private属性 [案例]super.属性名;
    2.访问父类的方法，不能访问父类的private方法 [案例]super.方法名(参数列表);
    3.访问父类的构造器(这点前面用过):super(参数列表);只能放在构造器的第一句,只能出现一句!
  细节

* 调用父类的构造器的好处：分工明确，父类属性由父类初始化，子类的属性由子类初始化
* 当子类中有和父类中的成员(属性和方法)重名时，为了指定访问父类的成员，必须通过super。如果没有重名的成员，使用super、this、直接访问是一样的效果!
* 子类直接调用某方法时，本类没有该方法则去找上级类
  先找本类：如果有，则调用。如果没有，则找父类(如果父类有，并可以调用，则调用)
  如果父类没有，则继续找父类的父类，直到Object类。
  提示:如果查找方法的过程中，找到了，但是不能访问，则报错
  如果查找方法的过程中，没有找到，则提示方法不存在
  如果通过this调用方法，本类没有再去找上级类
  如果通过super调用方法 直接去找上级类
* super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类(上级类)中都有同名的成员，使用super访问遵循就近原则。A->B->C

重写/覆盖
  介绍
    简单的说:方法覆盖(重写)就是子类有一个方法,和父类的某个方法的名称、返回类型、参数一样,那么我们就说子类的这个方法覆盖了父类的那个方法
  注意事项和细节
    1.子类的[方法的参数,方法名称],要和父类方法的参数,方法名称完全一样。
    2.子类方法的返回类型和父类方法[返回类型一样],或者是父类[返回类型的子类],比如父类返回类型是Object ,子类方法返回类型是String
    3.子类方法不能缩小父类方法的访问权限(多态问题)

多态
  介绍
    方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。
  体现
    1.方法的多态 重写/重载就体现多态
    2.[对象的多态]
      (1)一个对像的编译类型和运行类型可以不一致
      (2)编译类型在定义对象时，就确定了，不能改变
      (3)运行类型是可以变化的.
      (4)编译类型看定义时=号的左边，运行类型看=号的右边
        Animal animal = new Dog; (animal编译类型是Animal,运行类型Dog)
        animal编译类型是Animal,可以指向Animal子类的对象
  细节
    多态的前提是:两个对象(类)存在继承关系
    多态的向上转型
      1)本质:父类的引用指向了子类的对象
      2)语法:父类类型引用名=new子类类型();
      3)特点:编译类型看左边,运行类型看右边。
        [可以调用父类中的所有成员](需遵守访问权限).
        [不能调用子类中特有成员];
        [最终运行效果看子类的具体实现],即调用方法时，按照从子类开始查找方法，规则与之前一致
    多态的向下转型
      1)本质:父类的引用指向了子类的对象
      2)语法:子类类型 引用名=(子类类型)父类引用;
      3)特点：只能[强转父类的引用]，[不能强转父类的对象]
        要求父类的引用必须指向的是当前目标类型的对象
        当向下转型后，可以调用子类类型中所有的成员
    多态的向上转型和向下转型关系
      对象向下转型是对象向上转型的逆操作.
      先有向上转型才能向下转型
  多态下的注意事项
    1.[属性没有重写之说!属性的值看编译类型] 与方法有区别
    2.instanceOf 比较操作符，用于判断对象的[运行类型]是否为XX类型或XX类型的子类型
      if(aa instanceOf AA) 判断aa是否为AA类型或者AA类型的子类型

  多态下的动态绑定机制[非常重要] DynamicBinding
    1.当调用对象方法的时候,[该方法会和该对象的内存地址/运行类型绑定]
    2.[当调用对象属性时，没有动态绑定机制]，哪里声明，哪里使用

  多态数组
    介绍
      数组的定义类型为父类类型,里面保存的实际元素类型为子类类型

  多态参数
    介绍
      方法定义的形参类型为父类类型,实参类型允许为子类类型
