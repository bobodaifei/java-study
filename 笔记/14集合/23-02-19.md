关键字 集合框架体系 Collection Map Collections

集合的理解喝好处
  数组的缺点
    1)长度开始时必须指定，而且一旦指定,不能更改
    2)保存的必须为同一类型的元素
    3)使用数组进行增加元素的示意代码-比较麻烦
  集合的优点
    1)可以[动态保存任意多个对象],使用比较方便!
    2)提供了一系列方便的操作对象的方法:[add、remove,set,get]等
    3)使用集合[添加,删除]新元素的示意代码-[简洁]了

集合框架体系
  Collection[接口] [单列集合，存放的是单个对象，他们的实现子类都是单列集合]
    List[接口] [继承Collection]
      ArrayList 实现
      LinkedList 实现
      Vector 实现
    Set[接口] [继承Collection]
      HashSet 实现
      TreeSet 实现
  Map[接口] [双列集合，键值对，存放K-V]
    HashMap 实现Map
      LinkedHashMap 继承
    Hashtable 实现Map
      Properties 继承
    TreeMap 实现Map

Collection
  Collection接口的特点 public interface Collection<E> extends Iterable<E> 
    1)collection实现子类可以存放多个元素,[每个元素可以是Object]
    2)有些Collection的实现类,可以[存放重复的元素，有些不可以]
    3)有些Collection的实现类,有些是[有序]的(List)，有些[不是有序]的(Set)
    4)Collection接口[没有直接的实现子类],是通过它的子接口Set和List来实现的
  [Collection接口和常用方法]
    1) add:添加单个元素
    2) remove:删除指定元素(List可以按[下标]，也可以删除[某个对象])
    3) contains:查找元素是否存在
    4) size:获取元素个数
    5) isEmpty:判断是否为空
    6) clear:清空
    7) addAll:添加多个元素(参数为集合)
    8) containsAll:查找多个元素是否同时存在(参数为集合)
    9) removeAll:删除多个元素(参数为集合)
  Collection接口遍历元素方式1-使用[lterator](迭代器) 类似链式遍历
    1) lterator对象称为迭代器，主要用于遍历Collection集合中的元素。
    2) 所有实现了Collection接口的集合类都有一个[iterator()方法],用以返回一个实现了lterator接口的对象,即可以返回一个迭代器。
    3) Iterator的结构.
    4) Iterator[仅用于遍历集合]，Iterator 本身并不存放对象。
      [迭代器的执行原理]  //在调用iterator.next()方法之前必须要调用iterator.hasNext()进行检测。若不调用，且下一条记录无效,直接调用iterator.next()会抛出NoSuchElementException异常。
        lterator iterator = coll.iterator();//[得到一个coll集合的迭代器]
        while(iterator.hasNext(){  //hasNext(:[判断是否还有下一个元素]
          Object next = iterator.next();//next():1.下移2.将下移以后集合位置上的[元素返回]
        }//当[退出循环后]，iterator指向[最后一个元素]。如果再次遍历 需要[重置迭代器] 方法iterator = coll.iterator();
  Collection接口遍历对象方式2-for循环增强.
    增强for循环，可以代替iterator迭代器,
    特点:增强for就是[简化版的iterator],本质仍然是迭代器。只能用于[遍历集合或数组]。
    基本语法
      for(元素类型元素名:集合名或数组名){
        访问元素
      }

List
  List接口
    1) List集合类中[元素有序](即添加顺序和取出顺序一致)、且[可重复]
    2) List集合中的每个元素都有其对应的[顺序索引]，即支持索引。
    3) List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
    4) JDK API中List接口的实现类有:ArrayList LinkedList Vector
  List接口的常用方法 相对Collection额外的接口
    add(index,object)在index位置插入object
    addAll(index,collection)在index位置插入collection
    get(index)获取index位置的元素
    indexOf(object)返回首次出现的位置
    lastIndexOf(object)返回最后出现的位置
    remove(index)删除下标的元素
    set(index,object)替换index的元素为object
    subList(fromIndex,toIndex)获取从fromIndex到toIndex-1的元素
  三种遍历List
    1.iterator
    2.增强for
    3.普通for
  ArrayList注意事项
    1) ArrayList[可以加入null],并且多个
    2) ArrayList是由[数组来实现数据存储的]
    3) ArrayList [基本等同于Vector]，除了ArrayList是[线程不安全],[执行效率高]看源码.在多线程情况下，不建议使用ArrayList
  [ArrayList的底层操作机制源码分析](重点,难点)
    1) ArrayList中维护了一个Object类型的数组elementData. [transient] Object[] elementData;//transient表示瞬间的、短暂的。表示该属性[不会被序列化]
    2) 当创建ArrayList对象时，如果使用的是[无参构造器]，则初始elementData[容量为0]，[第1次添加]，则[扩容elementData为10]，如[需要再次扩容]，则[扩容elementData为1.5倍]。
    3) 如果使用的是[指定大小的构造器]，则[初始elementData容量为指定大小]，如果[需要扩容],则[直接扩容elementData为1.5倍]。
  Vector注意事项
    1) Vector类的定义说明
    2) Vector底层也是一个对象数组,protected Object[] elementData;
    3) Vector 是线程同步的，即线程安全, Vector类的操作方法带有synchronized
    4) 在开发中，[需要线程同步安全]时，考虑使用Vector
  Vector扩容机制
    1) 无参默认初始容量10，满后2倍扩容
    2) 单参构造器指定初始容量大小，满后2倍扩容
    3) 双参构造器指定初始容量大小和每次扩容大小，满后按照扩容大小扩容(需非0)
  LinkedList底层结构
    1) LinkedList底层实现了[双向链表]和[双端队列]特点
    2) 可以添加[任意元素](元素可以重复)，包括null
    3) [线程不安全]，没有实现同步
  LinkedList底层操作机制
    1) LinkedList底层维护了一个[双向链表].
    2) LinkedList中维护了两个属性[first和last]分别指向[首节点和尾节点]
    3) 每个节点([Node对象])，里面又维护了[prev、next、item]三个属性,其中通过[prev指向前一个]，通过[next指向后一个节点]。最终实现双向链表.
    4) 所以LinkedList的元素的[添加和删除]，不是通过数组完成的,相对来说[效率较高]。
    5) 模拟一个简单的双向链表走代码
  [ArrayList和LinkedList]的选择
    ArrayList     可变数组    增删效率低    查改效率高             
    LinkedList    双向链表    增删效率高    查改效率低    
    1)如果我们改查的操作多，选择ArrayList
    2)如果我们增删的操作多，选择LinkedList
    3)一般来说，在程序中，80%-90%都是查询，因此[大部分情况下会选择ArrayList]
    4)在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList,另外一个模块是LinkedList.

Set
  Set介绍
    1)[无序](不保证元素存放时和取出时的顺序是一致)，[没有索引]
    2)[不允许重复元素],[所以最多包含一个null]  (可以add重复的，不会报错)
    3)存放时无序，输出时固定[一个数组+链表的形式] [散列表.拉链法]
    4)JDK API中Set接口的实现类有:HashSet TreeSet
  Set接口的常用方法
    和List接口一样,Set接口也是Collection的子接口，因此,常用方法和Collection接口一样.
  Set接口的遍历方式
    同Collection的遍历方式一样,因为Set接口是Collection接口的子接口。
      1.可以[使用迭代器]
      2.[增强for]
      3.[不能使用索引]的方式来获取.
  HashSet
    说明
      1) HashSet[实现了Set接口]
      2) [HashSet实际上是HashMap]，看下源码.
      3) 可以存放null值，但是[只能有一个null]
      4) HashSet不保证元素存放时和取出时的顺序是一致的,[取决于hash后]，[再确定索引的结果].
      5) [不能有重复元素/对象].在前面Set 接口使用已经讲过
        特殊：正常下只要地址不同就可以存入，[但对于String的对象存入的是常量池的地址]
  HashSet底层机制说明
    分析HashSet底层是HashMap, HashMap底层是(数组+链表+红黑树)

  
    


















