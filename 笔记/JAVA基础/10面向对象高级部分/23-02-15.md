关键字 final关键字 抽象类 接口 内部类

final关键字
  介绍
    final可以修饰类、属性、方法和局部变量.
  使用需求
    1)当[不希望类被继承]时,可以用final修饰.
    2)当[不希望父类的某个方法被子类覆盖/重写](override)时,可以用final关键字修饰。
    3)当[不希望类的的某个属性的值被修改],可以用final修饰.
    4)当[不希望某个局部变量被修改]，可以使用final修饰
  注意细节
    1.final修饰的属性又叫常量,一般用xx_xx_xx来命名
    2.final修饰的属性在定义时,必须[赋初值],并且以后不能再修改，赋值可以在如下位置之一:
      [定义时赋值]
      [在构造器中赋值]
      [在代码块中赋值]
    3.如果final修饰的属性是静态的，则初始化的位置只能是
      [定义时]
      [在静态代码块，不能在构造器中赋值]
    4.final类不能继承,但是可以实例化对象。
    5.如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。
    6.一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。
    7.final不能修饰构造方法(即构造器)
    8.[final和static往往搭配使用]，可[简单理解为全局常量],效率更高，[不会导致类加载]，底层编译器做了优化处理。

抽象类
  引出
    当父类的一些方法不能确定时,可以用abstract关键字来修饰该方法，这个方法就是抽象方法,用abstract来修饰该类就是抽象类。
  介绍
    1)用abstract关键字来修饰一个类时,这个类就叫抽象类
      访问修饰符 abstract class 类名{}
    2)用abstract关键字来修饰一个方法时,这个方法就是抽象方法
      访问修饰符 abstract 返回类型 方法名(参数列表);//没有方法体
    3)抽象类的价值更多[作用是在于设计]，是设计者设计好后，让子类继承并实现抽象类
    4)抽象类,在框架和设计模式使用较多
  使用
    abstract class Animal{
      //设计为抽象方法，即未实现的方法，无方法体,且本类需要声明为抽象类
      public abstract void eat();
    }
    且抽象类被继承后由子类实现
  注意
    1)抽象类[不能被实例化]，[仍然存在构造器，用于子类的加载]
    2)抽象类不一定要包含abstract方法。也就是说,抽象类可以没有abstract方法
    3)一旦类包含了abstract方法,则这个类必须声明为abstract
    4)abstract[只能修饰类和方法]，不能修饰属性和其它的
    5)抽象类可以有任意成员[因为抽象类还是类]，比如:非抽象方法、构造器、静态属性等等
    6)抽象方法不能有主体，即不能实现.
    7)如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。
    8)抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的
    9）子类继承父类以后，子类依然不知道怎么重写的时候，子类仍然可以声明为抽象类

接口
  介绍
    接口就是给出一些没有实现的方法,封装到一起,到某个类要使用的时候,在根据具体情况把这些方法写出来。
  语法:
    interface接口名{
      //属性
      //[静态方法，默认方法,抽象方法]
    }
    class 类名 implements 接口{
      自己属性;
      自己方法;
      必须实现的接口的抽象方法
    }
  注：
    1.在Jdk7.0前接口里的所有方法都没有方法体，即都是抽象方法。
    2.[Jdk8.0后]接口类可以有[静态方法，默认方法,抽象方法]，也就是说接口中可以有方法的具体实现。
  本质
    从本质上讲,接口是一种特殊的抽象类,这种抽象类只包含常量和方法的定义,而没有变量和方法的实现
  细节
    1.接口不能被实例化
    2.接口中[所有的方法是public方法]，接口中抽象方法，[可以不用abstract修饰]
    3.一个普通类实现接口,就[必须将该接口的所有方法都实现]。
    4.[抽象类实现接口]，可以不用实现接口的方法。
    5.一个类同时可以实现多个接口[抽象类和接口的区别]
    6.接口中的属性,[只能是final的]，而且是 public static final修饰符
      比如int a=1; 实际是 public static final int a=1;
    7.接口中属性的访问形式:[接口名.属性名]
    8.一个接口不能继承其它的类,但是[可以继承多个别的接口]
    9.接口的修饰符只能是public 和默认，这点和类的修饰符是一样的。
  易错
    父类和实现的接口出现同名字段时 用[接口.字段] 和 [super.字段]区分

接口vs继承
  1.解决问题
    继承的价值主要在于:解决代码的复用性和可维护性。
    接口的价值主要在于:设计，设计好各种规范(方法)，让其它类去实现这些方法。
  2.接口比继承更灵活
    接口比继承更加灵活，继承是满足is - a的关系，而接口只需满足like - a的关系。
  3.接口在一定程度上实现代码解耦[规范+动态绑定]

接口的多态特性
  1.多态参数
  2.多态数组
    判断对象类型还是用instanceof
  3.接口存在多态传递（师傅的爸爸）
    可以实现子类继承父类的接口

内部类
  介绍
    一个[类的内部又完整的嵌套了另一个类结构]。[被嵌套]的类称为[内部类](inner class),[嵌套其他类]的类称为[外部类](outer class)。是我们类的第五大成员，内部类[最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系]
  语法
    class Outer{//外部类
      class Inner{//内部类
      }
    }
    class Other{//其他类
    }
  分类
    1.定义在[外部类局部位置]上(比如方法内):
      1)[局部内部类](有类名)
        说明:局部内部类是定义在外部类的局部位置,比如[方法中、代码块]，并且有类名
        细节
          1.可以[直接访问]外部类的[所有成员]，包含私有的
          2.[不能添加访问修饰符],因为它的地位就是一个[局部变量]。局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量也可以使用final
          3.作用域:仅仅在[定义它的方法或定义它的代码块中]。
          4.局部内部类---可以访问--->外部类的成员[访问方式:直接访问]
          5.外部类([必须在局部内部类所在的作用域内])---可以访问--->局部内部类的成员,访问方式:创建对象，再访问
          6.外部其他类---不能访问--->局部内部类（因为局部内部类地位是一个局部变量)
          7.如果外部类和局部内部类的成员重名时，默认[遵循就近原则]，如果想访问外部类的成员，则可以使用[外部类名.this.成员]去访问
            [外部类名.this]本质就是外部类的对象，即哪个对象被调用，外部类名.this就是哪个对象
            此处[this]指的是本内部类
      2)[匿名内部类](没有类名，重点!!!!!!!!)
        说明:匿名内部类是定义在外部类的局部位置，比如[方法中、代码块]，并且没有类名
          1.本质是类
          2.是内部类
          3.匿名内部类没有名字
          4.同时还是一个对象
        使用[接口式匿名内部类]
          1.起因：想实现某个接口，但[只是使用一次]。传统方式，是写一个类，实现该接口，并创建对象。
          2.现在使用匿名内部类
            IA tiger = new IA() {
              @Override
              public void cry() {
                System.out.println("aoaojiao");
              }
              //实现代码/...
            };
          3.tiger的编译类型?IA
          4.tiger的运行类型?就是匿名内部类 XXXX
            XXXX = 外部类$1
          5.jdk底层在创建匿名内部类[外部类$1]，立马就创建了[外部类$1]实例，并把地址返回给tiger
          6.匿名内部类在使用后销毁
        使用[类式匿名内部类]
          本质：匿名内部类本质就是一个继承父类的匿名子类的对象
          1.起因：想继承某个类，但[只是使用一次]。传统方式，是写一个类，继承该类，并创建对象。
          2.现在使用匿名内部类
            IB ib = new IB(构造器实参){
              @Override
              public void cry() {
                System.out.println("aoaojiao");
              }
              //重写代码/...
            };
          3.ib的编译类型?IB
          4.ib的运行类型?就是匿名内部类 XXXX
            XXXX = 外部类$1 [此处为IB$1] $后是按照第几个加载的匿名内部类书写的
          5.jdk底层在创建匿名内部类[外部类$1]，立马就创建了[外部类$1]实例，并把地址返回给tiger
          6.匿名内部类在使用后销毁
          7.相当于返回一个对象，可以不返回地址直接调用方法
        细节
          1.匿名内部类的语法比较奇特，注意,因为匿名内部类既是一个类的定义同时它本身也是一个对象，因此从语法上看,它既有定义类的特征，也有创建对象的特征,因此可以调用匿名内部类方法。
          2.可以直接访问外部类的所有成员,包含私有的
          3.不能添加访问修饰符,因为它的地位就是一个局部变量。
          4.作用域:仅仅在定义它的方法或代码块中。
          5.匿名内部类---访问--->外部类成员[访问方式:直接访问]
          6.外部其他类---不能访问--->匿名内部类（因为匿名内部类地位是一个局部变量)
          7.如果外部类和内部类的[成员重名]时，内部类访问的话，默认[遵循就近原则]，如果想访问外部类的成员，则可以使用[外部类名.this.成员]去访问
    2.定义在[外部类的成员位置]上:
      1)[成员内部类](没用static修饰)
        1.可以直接访问外部类的所有成员，包含私有的
        2.可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。
        3.和外部类的其他成员一样,为整个类体.在外部类的成员方法中创建成员内部类对象,再调用方法.
        4.成员内部类---访问--->外部类(比如:属性)[访问方式:直接访问]
        5.外部类---访问--->内部类(说明)访问方式:[创建对象,再访问]
        6.外部其他类---访问--->成员内部类
          1.外部类.new 成员内部类();[当作成员来调用]
          2.在外部类写一个返回成员内部类的方法
          `<!-- 3.new 外部类().new 成员内部类() -->`
        7.如果外部类和内部类的成员重名时，内部类访问的话,默认遵循就近原则,如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问
      2)[静态内部类](使用static修饰)
        说明：静态内部类是定义在外部类的成员位置,并且有static修饰
        1.可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员(new)
        2.可以添加任意访问修饰符(public.protected、默认、private),因为它的地位就是一个成员。
        3.作用域:同其他的成员,为整个类体
        4.静态内部类---访问--->外部类(比如:静态属性)[访问方式:直接访问所有静态成员]
        5.外部类---访问--->静态内部类访问方式:[创建对象，再访问]
        6.外部其他类---访问--->静态内部类
          1.new 外部类.静态内部类
          2.在外部类写一个返回静态内部类的方法
          3.外部类.返回静态内部类的方法(static)
        7.如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员)去访问
