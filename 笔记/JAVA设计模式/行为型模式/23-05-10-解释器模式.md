# 解释器模式

## 四则运算问题

通过解释器模式来实现四则运算，如计算 `a + b - c`的值，具体要求

* 先输入表达式的形式，比如 `a + b + c - d + e`，要求表达式的字母不能重复
* 在分别输入 `a, b, c, d, e`的值
* 最后求出结果：如图

![image-20220115215331808](https://s2.loli.net/2022/01/15/Br8E7vKUJHNs6ZF.png)

**传统方案解决四则运算问题分析**

* 编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果
* 问题分析：如果加入新的运算符，比如 `* / (`等等，不利于扩展，另外让一个方法来解析会造成程序结构混乱，不够清晰
* 解决方案：可以考虑使用解释器模式，即：表达式 => 解释器（可以有多种） => 结果

## 解释器模式的基本介绍

* 在编译原理中，一个=算术表达式=通过=词法分析器=形成 =词法单元= ，而后这些=词法单元=再通过=语法分析器=构建 =语法分析树= ，最终形成一颗 =抽象的语法分析树= 。这里的=词法分析器=和=语法分析器=都可以看做是解释器
* 解释器模式（Interpreter Pattern）：是指给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）
* 应用场景
  * 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
  * 一些重复出现的问题可以用一种简单的语言来表达
  * 一个简单语法需要解释的场景
* 这样的例子还有，比如=编译器、运算表达式计算、正则表达式、机器人=等

**原理类图**

![image-20220115220756742](https://s2.loli.net/2022/01/15/kEWMS3rshKcTwOy.png)

**解释器模式的角色及职责**

* `Context`环境角色：含有解释器之外的全局信息
* `AbstractExpression`抽象表达式：声明一个抽象的解释操作，该方法为抽象语法树中所有节点共享
* `TerminalExpression`终结符表达式：实现与文法中终结符相关的解释操作
* `NonTerminalExpression`非终结符表达式：实现与文法中非终结符相关的解释操作
