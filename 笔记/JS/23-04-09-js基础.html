<!DOCTYPE html>
<html>
<head>
<title>23-04-09-js基础.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*

Arduino® Light Theme - Stefania Mellai <s.mellai@arduino.cc>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  background: #FFFFFF;
}

.hljs,
.hljs-subst {
  color: #434f54;
}

.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-doctag,
.hljs-name {
  color: #00979D;
}

.hljs-built_in,
.hljs-literal,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #D35400;
}

.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #00979D;
}

.hljs-type,
.hljs-string,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #005C5F;
}

.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold;
}

.hljs-comment {
  color: rgba(149,165,166,.8);
}

.hljs-meta-keyword {
  color: #728E00;
}

.hljs-meta {
  color: #434f54;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-function {
  color: #728E00;
}

.hljs-number {
  color: #8A7B52;  
}

</style>

<style>
@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(fonts/KaTeX_AMS-Regular.woff2) format("woff2"),url(fonts/KaTeX_AMS-Regular.woff) format("woff"),url(fonts/KaTeX_AMS-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Caligraphic-Bold.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Bold.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Caligraphic-Regular.woff2) format("woff2"),url(fonts/KaTeX_Caligraphic-Regular.woff) format("woff"),url(fonts/KaTeX_Caligraphic-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Fraktur-Bold.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Bold.woff) format("woff"),url(fonts/KaTeX_Fraktur-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Fraktur-Regular.woff2) format("woff2"),url(fonts/KaTeX_Fraktur-Regular.woff) format("woff"),url(fonts/KaTeX_Fraktur-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(fonts/KaTeX_Main-Bold.woff2) format("woff2"),url(fonts/KaTeX_Main-Bold.woff) format("woff"),url(fonts/KaTeX_Main-Bold.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Main-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Main-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Main-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Main-Italic.woff2) format("woff2"),url(fonts/KaTeX_Main-Italic.woff) format("woff"),url(fonts/KaTeX_Main-Italic.ttf) format("truetype")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Main-Regular.woff2) format("woff2"),url(fonts/KaTeX_Main-Regular.woff) format("woff"),url(fonts/KaTeX_Main-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(fonts/KaTeX_Math-BoldItalic.woff2) format("woff2"),url(fonts/KaTeX_Math-BoldItalic.woff) format("woff"),url(fonts/KaTeX_Math-BoldItalic.ttf) format("truetype")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(fonts/KaTeX_Math-Italic.woff2) format("woff2"),url(fonts/KaTeX_Math-Italic.woff) format("woff"),url(fonts/KaTeX_Math-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:700;src:url(fonts/KaTeX_SansSerif-Bold.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Bold.woff) format("woff"),url(fonts/KaTeX_SansSerif-Bold.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:italic;font-weight:400;src:url(fonts/KaTeX_SansSerif-Italic.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Italic.woff) format("woff"),url(fonts/KaTeX_SansSerif-Italic.ttf) format("truetype")}@font-face{font-family:"KaTeX_SansSerif";font-style:normal;font-weight:400;src:url(fonts/KaTeX_SansSerif-Regular.woff2) format("woff2"),url(fonts/KaTeX_SansSerif-Regular.woff) format("woff"),url(fonts/KaTeX_SansSerif-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Script-Regular.woff2) format("woff2"),url(fonts/KaTeX_Script-Regular.woff) format("woff"),url(fonts/KaTeX_Script-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size1-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size1-Regular.woff) format("woff"),url(fonts/KaTeX_Size1-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size2-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size2-Regular.woff) format("woff"),url(fonts/KaTeX_Size2-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size3-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size3-Regular.woff) format("woff"),url(fonts/KaTeX_Size3-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Size4-Regular.woff2) format("woff2"),url(fonts/KaTeX_Size4-Regular.woff) format("woff"),url(fonts/KaTeX_Size4-Regular.ttf) format("truetype")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(fonts/KaTeX_Typewriter-Regular.woff2) format("woff2"),url(fonts/KaTeX_Typewriter-Regular.woff) format("woff"),url(fonts/KaTeX_Typewriter-Regular.ttf) format("truetype")}.katex{text-rendering:auto;font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:"0.16.2"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:"(" counter(katexEqnNo) ")";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:"(" counter(mmlEqnNo) ")";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}

</style>

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family:   "HelveticaNeue-Light", sans-serif, "宋体","Segoe WPC", "Segoe UI", "SFUIText-Light","Droid Sans Fallback";
	font-size: 18px;
	padding: 0 12px;
	line-height: 1.6;
	word-wrap: break-word;
	color: #333333;
}

.content-wrapper{
	max-width: 860px;
    margin: 0 auto;
    padding: 0 30px;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom: 1px solid #eee;
}


h2{
	padding-bottom: .3em;
    font-size: 2em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

h3{
	font-size: 1.75em;
    line-height: 1.225;
}

h1, h2, h3 {
	font-weight: bold;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

.table-of-contents li{
	list-style-type: initial;
}
</style>

</head>
<body>
    <div class="content-wrapper">
        <h1 id="js" tabindex="-1">JS</h1>
<h2 id="%E5%89%8D%E8%A8%80" tabindex="-1">前言</h2>
<ul>
<li>运行在浏览器的脚本语言（目标程序以文本格式打开）</li>
<li>用于网页和用户之间的交互，比如提交的时候，进行用户名是否为空的判断</li>
<li>Java运行在JVM当中，JavaScript运行在浏览器的内存当中</li>
<li>完整的javascript由语言基础,BOM,DOM组成</li>
</ul>
<h2 id="%E7%AE%80%E4%BB%8B" tabindex="-1">简介</h2>
<h3 id="%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86" tabindex="-1">组成部分</h3>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ECMA Script</td>
<td>构成了JS核心的语法基础（ES规范 / ECMA-262标准）</td>
</tr>
<tr>
<td>BOM Browser Object Model</td>
<td>浏览器对象模型，用来操作浏览器上的对象</td>
</tr>
<tr>
<td>DOM Document Obiect Model</td>
<td>文档对象模型，用来操作网页中的元素</td>
</tr>
</tbody>
</table>
<h3 id="%E7%89%B9%E7%82%B9" tabindex="-1">特点</h3>
<ol>
<li>开发工具简单，记事本即可</li>
<li>无需编译，直接由数据 JS引擎负责执行</li>
<li>弱类型语言 由数据来决定数据类型</li>
<li>面向对象</li>
</ol>
<h3 id="%E4%BD%9C%E7%94%A8" tabindex="-1">作用</h3>
<ol>
<li>嵌入动态文本与HTML页面</li>
<li>对浏览器时间做出响应</li>
<li>读写HTML元素</li>
<li>在数据被提交到服务器之前验证数据</li>
<li>检测访客的浏览器信息</li>
<li>控制cookies，包括创建和修改等。</li>
<li>基于node.js技术进行服务器端编程。</li>
</ol>
<h2 id="js%E4%B8%89%E7%A7%8D%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%BC%8F" tabindex="-1">JS三种添加方式</h2>
<h3 id="%E8%A1%8C%E5%86%85%E5%BC%8F" tabindex="-1">行内式</h3>
<ul>
<li>事件句柄=“js代码”，把这段代码注册到onclick之后，有操作后，js代码会在浏览器被自动调用</li>
<li>弹窗消息的用法是：window.alert(“消息”)</li>
<li>JS中的一条语句结束之后可以使用分号“;”，也可以不用</li>
<li>JS中的字符串可以使用双引号，也可以使用单引号</li>
</ul>
<pre class='hljs'><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;行内js&#x27;)&quot;</span>&gt;</span>单击试试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!--
1、JS是一门事件驱动型的编程语言，依靠事件去驱动，然后执行对应的程序。
在JS中有很多事件，其中有一个事件叫做：鼠标单击，单词：click。并且任何
事件都会对应一个事件句柄叫做：onclick。【注意：事件和事件句柄的区别是：
事件句柄是在事件单词前添加一个on。】，而事件句柄是以HTML标签的属性存在的。

2、οnclick=&quot;js代码&quot;，执行原理是什么？
页面打开的时候，js代码并不会执行，只是把这段JS代码注册到按钮的click事件上了。
等这个按钮发生click事件之后，注册在onclick后面的js代码会被浏览器自动调用。

3、怎么使用JS代码弹出消息框？
在JS中有一个内置的对象叫做window，全部小写，可以直接拿来使用，window代表的是浏览器对象。
window对象有一个函数叫做:alert，用法是：window.alert(&quot;消息&quot;);这样就可以弹窗了。
--&gt;</span>
</div></code></pre>
<h3 id="%E5%86%85%E5%B5%8C%E5%BC%8F" tabindex="-1">内嵌式</h3>
<p>通过脚本块的方式，页面打开的时候执行，并且遵守自上而下的顺序依次逐行执行。（这个代码的执行不需要事件）。（CSS为样式块）</p>
<ul>
<li>javascript的脚本块在一个页面当中可以出现多次。没有要求</li>
<li>javascript的脚本块出现位置也没有要求，随意</li>
<li>alert有阻塞当前页面加载的作用。（阻挡，直到用户点击确定按钮。）</li>
</ul>
<pre class='hljs'><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
alert(<span class="hljs-string">&#x27;内嵌js&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<h3 id="%E5%A4%96%E9%93%BE%E5%BC%8F" tabindex="-1">外链式</h3>
<p>外部引入js文件</p>
<ul>
<li>同一个js文件可以被引入多次，但实际开发中这种需求很少</li>
<li>引入js文件的同时再写代码，文件会被执行，但代码块不会被执行。但分别两个script，一个引入一个写代码是可以的</li>
</ul>
<pre class='hljs'><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js文件路径地址&quot;</span>&gt;</span>这里不能写js语句<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<h2 id="%E5%8F%98%E9%87%8F" tabindex="-1">变量</h2>
<h3 id="%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC" tabindex="-1">变量的声明与赋值</h3>
<ul>
<li>java中要求变量声明的时候是什么类型，不可变。编译期强行固定变量的数据类型称为强类型语言。数据类型 变量名;</li>
<li>对比javascript，javascript是一种弱类型语言，没有编译阶段，一个变量可以随意赋值，赋什么类型的值都行，var 变量名;</li>
<li>当系统没有赋值的时候，会默认给undefined，undefined是系统的一个存在值</li>
<li>当系统直接没声明直接调用一个值，会报错</li>
</ul>
<pre class='hljs'><code><div>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;
	<span class="hljs-keyword">var</span> a, b, c = <span class="hljs-number">200</span>;
	alert(<span class="hljs-string">&quot;a = &quot;</span> + a);
	alert(<span class="hljs-string">&quot;b = &quot;</span> + b);
	alert(<span class="hljs-string">&quot;c = &quot;</span> + c);
		   
	a = <span class="hljs-literal">false</span>;
	alert(a);
		   
	a = <span class="hljs-string">&quot;abc&quot;</span>;
	alert(a);
		   
	a = <span class="hljs-number">1.2</span>;
	alert(a);	   
&lt;/script&gt;
</div></code></pre>
<h3 id="%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83" tabindex="-1"><strong>变量命名规范</strong></h3>
<ol>
<li>只能由字母、数字、_（下划线）、$（美元符号）组成。</li>
<li>不能以数字开头。</li>
<li>命名中不能出现-（js会理解成减号进行减法的操作），不能和关键字冲突。</li>
</ol>
<h3 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" tabindex="-1">数据类型</h3>
<p>数据类型有：原始类型、引用类型</p>
<ul>
<li>原始类型：undefined、number、string、boolean、null</li>
<li>引用类型：object以及object的子类</li>
</ul>
<pre class='hljs'><code><div><span class="hljs-keyword">var</span> i;
alert(<span class="hljs-keyword">typeof</span> i); <span class="hljs-comment">// &quot;undefined&quot;</span>

<span class="hljs-keyword">var</span> k = <span class="hljs-number">10</span>;
alert(<span class="hljs-keyword">typeof</span> k); <span class="hljs-comment">// &quot;number&quot;</span>

<span class="hljs-keyword">var</span> f = <span class="hljs-string">&quot;abc&quot;</span>;
alert(<span class="hljs-keyword">typeof</span> f); <span class="hljs-comment">// &quot;string&quot;</span>

<span class="hljs-keyword">var</span> d = <span class="hljs-literal">null</span>;
alert(<span class="hljs-keyword">typeof</span> d); <span class="hljs-comment">// &quot;object&quot;  null属于Null类型,但是typeof运算符的结果是&quot;object&quot;</span>

<span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span>;
alert(<span class="hljs-keyword">typeof</span> flag); <span class="hljs-comment">// &quot;boolean&quot;</span>

<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
alert(<span class="hljs-keyword">typeof</span> obj); <span class="hljs-comment">// &quot;object&quot;</span>

<span class="hljs-comment">// sayHello是一个函数.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>{
  
}
alert(<span class="hljs-keyword">typeof</span> sayHello); <span class="hljs-comment">// &quot;function&quot;</span>
</div></code></pre>
<h3 id="%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" tabindex="-1">检测数据类型</h3>
<p>typeof(value); 或 typeof value;   返回这个变量的类型</p>
<p>说明 : 同一个变量, 可以进行不同类型的数据赋值。</p>
<p>在JS当中比较字符串是否相等使用“==”完成。没有equals</p>
<pre class='hljs'><code><div><span class="hljs-keyword">typeof</span>运算符的语法格式：
	<span class="hljs-keyword">typeof</span> 变量名

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>)</span>{
   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> a == <span class="hljs-string">&quot;number&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b == <span class="hljs-string">&quot;number&quot;</span>){
	   <span class="hljs-keyword">return</span> a + b;
   }
   alert(a + <span class="hljs-string">&quot;,&quot;</span> + b + <span class="hljs-string">&quot;必须都为数字！&quot;</span>);
}

</div></code></pre>
<h3 id="%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87" tabindex="-1">变量提升</h3>
<p><strong>javascript并不是严格的自上而下执行的语言 。它会将当前作用域的所有变量的声明提升到程序的顶部。</strong></p>
<h3 id="%E7%BB%86%E8%AE%B2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" tabindex="-1">细讲数据类型</h3>
<h4 id="undefined" tabindex="-1">undefined</h4>
<p>当一个变量没有手动赋值，系统默认赋值undefined，或者也可以给一个变量手动赋值undefined</p>
<pre class='hljs'><code><div><span class="hljs-keyword">var</span> i; <span class="hljs-comment">// undefined</span>
<span class="hljs-keyword">var</span> k = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// undefined</span>

alert(i == k); <span class="hljs-comment">// true</span>

<span class="hljs-keyword">var</span> y = <span class="hljs-string">&quot;undefined&quot;</span>; <span class="hljs-comment">// &quot;undefined&quot;是一个字符串类型</span>
alert(y == k); <span class="hljs-comment">// false</span>

</div></code></pre>
<h4 id="number" tabindex="-1">number</h4>
<p>Number类型包括整数、小数、正数、负数、不是数字、无穷大等。比如 -1 0 1 2 2.3 3.14 100 … NaN Infinity等都属于Number</p>
<pre class='hljs'><code><div><span class="hljs-comment">// Infinity (当除数为0的时候，结果为无穷大)</span>
alert(<span class="hljs-number">10</span> / <span class="hljs-number">0</span>);
</div></code></pre>
<p>补充关于NaN（(表示Not a Number，不是一个数字，但属于Number类型)）
运算结果本来应该是一个数字,最后算完不是一个数字的时候,结果是NaN</p>
<p><strong>isNaN函数</strong> （is Not a Number）</p>
<p>isNaN(数据) ，结果是true表示不是一个数字， 结果是false表示是一个数字</p>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>)</span>{
   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isNaN</span>(a) || <span class="hljs-built_in">isNaN</span>(b)){
	   alert(<span class="hljs-string">&quot;参与运算的必须是数字！&quot;</span>);
	   <span class="hljs-keyword">return</span>;
   }
   <span class="hljs-keyword">return</span> a + b;
}
sum(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;abc&quot;</span>);
alert(sum(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>));

</div></code></pre>
<p><strong>parseInt()或者parseFloat()函数</strong></p>
<p>可以将字符串自动转换成数字，并且取整数位，同理parseFloat也一样</p>
<pre class='hljs'><code><div>alert(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;3.9999&quot;</span>)); <span class="hljs-comment">// 3</span>
alert(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3.9999</span>)); <span class="hljs-comment">// 3</span>

<span class="hljs-comment">// parseFloat():可以将字符串自动转换成数字.</span>
alert(<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.14&quot;</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 4.14</span>
alert(<span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.2&quot;</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 4.2</span>

</div></code></pre>
<p><strong>Math.ceil()函数</strong></p>
<p>向上取整</p>
<pre class='hljs'><code><div><span class="hljs-comment">// Math.ceil()</span>
alert(<span class="hljs-built_in">Math</span>.ceil(<span class="hljs-string">&quot;2.1&quot;</span>)); <span class="hljs-comment">// 3</span>
</div></code></pre>
<h4 id="boolean" tabindex="-1">boolean</h4>
<p>对应true和false</p>
<pre class='hljs'><code><div><span class="hljs-comment">// 规律:“有&quot;就转换成true,&quot;没有&quot;就转换成false.</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// true</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// false</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// true</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// false</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// false</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// false</span>
alert(<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">Infinity</span>)); <span class="hljs-comment">// true</span>
</div></code></pre>
<p><strong>Boolean()函数</strong></p>
<p>Boolean()函数的作用是将非布尔类型转换成布尔类型</p>
<pre class='hljs'><code><div>语法格式：
		<span class="hljs-built_in">Boolean</span>(数据) 
</div></code></pre>
<h4 id="null" tabindex="-1">null</h4>
<p>Null类型是第二个只有一个值的类型，这个特殊值就是null，从逻辑的角度看，null值表示一个空对象指针，而这也正是typeof检测null值时会返回object的原因。</p>
<pre class='hljs'><code><div><span class="hljs-comment">// Null类型只有一个值,null</span>
alert(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;object&quot;</span>
</div></code></pre>
<h4 id="string" tabindex="-1">String</h4>
<p>在JS当中字符串可以使用单引号，也可以使用双引号</p>
<pre class='hljs'><code><div><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;abcdef&#x27;</span>;
<span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;test&quot;</span>;
</div></code></pre>
<p>两种创建对象的方式，但创建的对象的类型有所不同
String是一个内置的类，可以直接用，String的父类是Object</p>
<pre class='hljs'><code><div><span class="hljs-comment">//第一种：</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;abc&quot;</span>;
<span class="hljs-comment">//第二种（使用JS内置的支持类String）： </span>
<span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);

<span class="hljs-comment">// 小string(属于原始类型String)</span>
<span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;king&quot;</span>;
alert(<span class="hljs-keyword">typeof</span> x); <span class="hljs-comment">// &quot;string&quot;</span>

<span class="hljs-comment">// 大String(属于Object类型)</span>
<span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);
alert(<span class="hljs-keyword">typeof</span> y); <span class="hljs-comment">// &quot;object&quot;</span>
</div></code></pre>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>indexOf</td>
<td>获取指定字符串在当前字符串中第一次出现处的索引</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>获取指定字符串在当前字符串中最后一次出现处的索引</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
</tr>
<tr>
<td>substr</td>
<td>截取子字符串（下标，长度）</td>
</tr>
<tr>
<td>substring</td>
<td>截取子字符串【开始下标，结束下标）</td>
</tr>
<tr>
<td>toLowerCase</td>
<td>转换小写</td>
</tr>
<tr>
<td>toUpperCase</td>
<td>转换大写</td>
</tr>
<tr>
<td>split</td>
<td>拆分字符串</td>
</tr>
</tbody>
</table>
<h4 id="object" tabindex="-1">Object</h4>
<p>Object类型是所有类型的超类，自定义的任何类型，默认继承Object</p>
<p>js定义类的方式</p>
<pre class='hljs'><code><div>定义类的语法：
第一种方式：
<span class="hljs-function"><span class="hljs-keyword">function</span> 类名(<span class="hljs-params">形参</span>)</span>{

}
第二种方式：
类名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">形参</span>)</span>{

}
第三种方式：
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Persion</span></span>{
      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>{
        <span class="hljs-built_in">this</span>.name =name;
      }
      <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> {
        alert(<span class="hljs-string">&#x27;Persion&#x27;</span>);
      }
    }
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Persion</span></span>{
      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>{
        <span class="hljs-built_in">super</span>(name);
      }
      <span class="hljs-function"><span class="hljs-title">ufn</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">//super为People原型对象</span>
        <span class="hljs-comment">//People.prototype.fn.call(this);</span>
        <span class="hljs-built_in">super</span>.fn();
      }
    }
创建对象的语法：
<span class="hljs-keyword">new</span> 构造方法名(实参); <span class="hljs-comment">// 构造方法名和类名一致。</span>

</div></code></pre>
<p>js的类定义以及探讨</p>
<pre class='hljs'><code><div><span class="hljs-comment">// 定义一个学生类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params"></span>)</span>{
   alert(<span class="hljs-string">&quot;Student.....&quot;</span>);
}

<span class="hljs-comment">// 当做普通函数调用，方法三不适用</span>
Student();

<span class="hljs-comment">// 当做类来创建对象</span>
<span class="hljs-keyword">var</span> stu = <span class="hljs-keyword">new</span> Student();
alert(stu); <span class="hljs-comment">// [object Object]</span>

</div></code></pre>
<p>JS中的类的定义，同时又是一个构造函数的定义
在JS中类的定义和构造函数的定义是放在一起来完成的
js的函数形参调用可以有一个或者多个都可以执行，因为是弱类型</p>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">a, b, c</span>)</span>{ <span class="hljs-comment">// a b c是形参,属于局部变量.</span>
   <span class="hljs-comment">// 声明属性 (this表示当前对象)</span>
   <span class="hljs-comment">// User类中有三个属性:sno/sname/sage</span>
   <span class="hljs-built_in">this</span>.sno = a;
   <span class="hljs-built_in">this</span>.sname = b;
   <span class="hljs-built_in">this</span>.sage = c;
}

<span class="hljs-comment">// 创建对象</span>
<span class="hljs-keyword">var</span> u1 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">111</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">30</span>);
<span class="hljs-comment">// 访问对象的属性</span>
alert(u1.sno);
alert(u1.sname);
alert(u1.sage);

<span class="hljs-keyword">var</span> u2 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">222</span>, <span class="hljs-string">&quot;jackson&quot;</span>, <span class="hljs-number">55</span>);
alert(u2.sno);
alert(u2.sname);
alert(u2.sage);

<span class="hljs-comment">// 访问一个对象的属性,还可以使用这种语法</span>
alert(u2[<span class="hljs-string">&quot;sno&quot;</span>]);
alert(u2[<span class="hljs-string">&quot;sname&quot;</span>]);
alert(u2[<span class="hljs-string">&quot;sage&quot;</span>]);

</div></code></pre>
<p>也可以换种方式定义类</p>
<pre class='hljs'><code><div>Product = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pno,pname,price</span>)</span>{
   <span class="hljs-comment">// 属性</span>
   <span class="hljs-built_in">this</span>.pno = pno;
   <span class="hljs-built_in">this</span>.pname = pname;
   <span class="hljs-built_in">this</span>.price = price;
   <span class="hljs-comment">// 函数</span>
   <span class="hljs-built_in">this</span>.getPrice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
	   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.price;
   }
}

<span class="hljs-keyword">var</span> xigua = <span class="hljs-keyword">new</span> Product(<span class="hljs-number">111</span>, <span class="hljs-string">&quot;西瓜&quot;</span>, <span class="hljs-number">4.0</span>);
<span class="hljs-keyword">var</span> pri = xigua.getPrice();
alert(pri); <span class="hljs-comment">// 4.0</span>

</div></code></pre>
<p>属性有：prototype属性（常用的，主要是这个）：作用是给类动态的扩展/挂载属性和函数。constructor属性</p>
<pre class='hljs'><code><div><span class="hljs-comment">// 可以通过prototype这个属性来给类动态扩展属性以及函数</span>
Product.prototype.getPname = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.pname;
}

<span class="hljs-comment">// 调用后期扩展的getPname()函数</span>
<span class="hljs-keyword">var</span> pname = xigua.getPname();
alert(pname)

<span class="hljs-comment">// 给String扩展一个函数</span>
<span class="hljs-built_in">String</span>.prototype.suiyi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
   alert(<span class="hljs-string">&quot;这是给String类型扩展的一个函数，叫做suiyi&quot;</span>);
}

<span class="hljs-string">&quot;abc&quot;</span>.suiyi();

</div></code></pre>
<p>对比一下java类型定义与js类型定义</p>
<p>java语言怎么定义类，怎么创建对象？（强类型）</p>
<pre class='hljs'><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>{
	<span class="hljs-keyword">private</span> String username;
	<span class="hljs-keyword">private</span> String password;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span></span>{

	}
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username,String password)</span></span>{
		<span class="hljs-keyword">this</span>.username = username;
		<span class="hljs-keyword">this</span>.password = password;
	}
}
User user = <span class="hljs-keyword">new</span> User();
User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);

</div></code></pre>
<p>JS语言怎么定义类，怎么创建对象？（弱类型）</p>
<pre class='hljs'><code><div>User = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username,password</span>)</span>{
	<span class="hljs-built_in">this</span>.username = username;
	<span class="hljs-built_in">this</span>.password = password;
}
<span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> User();
<span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>);
<span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);

或

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Persion</span></span>{
      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>{
        <span class="hljs-built_in">this</span>.name =name;
      }
      <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> {
        alert(<span class="hljs-string">&#x27;Persion&#x27;</span>);
      }
    }
</div></code></pre>
<h4 id="null%E3%80%81nan%E5%92%8Cundefined" tabindex="-1">null、NaN和undefined</h4>
<ul>
<li>数据类型不一致</li>
<li>==(等同运算符：只判断值是否相等)
===(全等运算符：既判断值是否相等，又判断数据类型是否相等)</li>
</ul>
<pre class='hljs'><code><div><span class="hljs-comment">// null NaN undefined 数据类型不一致.</span>
alert(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;object&quot;</span>
alert(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// &quot;number&quot;</span>
alert(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// &quot;undefined&quot;</span>

<span class="hljs-comment">// null和undefined可以等同.</span>
alert(<span class="hljs-literal">null</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span>
alert(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span>
alert(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// 在JS当中有两个比较特殊的运算符</span>
alert(<span class="hljs-literal">null</span> === <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span>
alert(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// false</span>
alert(<span class="hljs-literal">undefined</span> === <span class="hljs-literal">NaN</span>); <span class="hljs-comment">// false</span>

</div></code></pre>
<h2 id="%E5%87%BD%E6%95%B0%EF%BC%88%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%89" tabindex="-1">函数（特殊的对象）</h2>
<h3 id="%E5%85%B7%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8" tabindex="-1">具名函数的定义与使用</h3>
<p>函数类似java中的方法，java中定义方法的格式是</p>
<pre class='hljs'><code><div>[修饰符列表] 返回值类型 方法名(形式参数列表){
	方法体;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>{
	...
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}

<span class="hljs-keyword">boolean</span> loginSuccess = login(<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);

</div></code></pre>
<p>而js是一种弱类型，js中的函数不需要 指定返回值类型，返回什么类型都行，函数的定义格式是</p>
<pre class='hljs'><code><div><span class="hljs-comment">//第一种方式：</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">形式参数列表</span>)</span>{
	 函数体;
}
<span class="hljs-comment">//第二种方式：</span>
函数名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">形式参数列表</span>)</span>{
	函数体;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>)</span>{
<span class="hljs-comment">// a和b都是局部变量,他们都是形参(a和b都是变量名，变量名随意。)</span>
	alert(a + b);
}

sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//函数必须调用才能执行</span>

<span class="hljs-comment">//或者第二个格式</span>
<span class="hljs-comment">// 定义函数sayHello</span>
sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username</span>)</span>{
	alert(<span class="hljs-string">&quot;hello &quot;</span> + username);
}
		   
<span class="hljs-comment">// 调用函数</span>
sayHello(<span class="hljs-string">&quot;zhangsan&quot;</span>);

</div></code></pre>
<p><strong>配合单击按钮框的逻辑完整代码如下</strong></p>
<pre class='hljs'><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JS函数初步<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">

		   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>)</span>{
			   <span class="hljs-comment">// a和b都是局部变量,他们都是形参(a和b都是变量名，变量名随意。)</span>
			   alert(a + b);
		   }

		   sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username</span>)</span>{
			   alert(<span class="hljs-string">&quot;hello &quot;</span> + username);
		   }
		   
		   <span class="hljs-comment">// 调用函数</span>
		   sayHello(<span class="hljs-string">&quot;zhangsan&quot;</span>);
		   
		</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;sayHello(&#x27;jack&#x27;);&quot;</span> /&gt;</span> 
		<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;计算10和20的求和&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;sum(10, 20);&quot;</span> /&gt;</span>

	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</div></code></pre>
<h3 id="%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0(%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9B%B8%E4%BC%BC)" tabindex="-1">匿名函数(与匿名内部类相似)</h3>
<p>定义：即没有名字的函数</p>
<p>注意：</p>
<ol>
<li>var init = function() { }是函数表达式，函数在代码执行的到当前行的时候才被执行，init 才被赋值。</li>
<li>function init() {} 是函数的声明，和 var 一样，会被提前到代码最前面定义。</li>
<li>添加后再移除事件要用具名函数</li>
</ol>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">形式参数</span>)</span>{函数体}
定义函数并赋值给变量：<span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">形式参数</span>)</span>{函数体}

调用方式：将匿名函数赋值给一个变量，通过变量名调用函数
调用函数：fn(实际参数);

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">
 
    <span class="hljs-comment">// 匿名函数 : 即没有名称的函数</span>
    <span class="hljs-keyword">var</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, u</span>) </span>{
        alert(i + <span class="hljs-string">&quot; 喜欢 &quot;</span> + u);
    }
 
    <span class="hljs-comment">// 调用函数 :</span>
   func(<span class="hljs-string">&quot;我&quot;</span>, <span class="hljs-string">&quot;你&quot;</span>);<span class="hljs-comment">//显示 我喜欢你</span>
 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

</div></code></pre>
<h4 id="%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0" tabindex="-1">自执行函数</h4>
<p>没有名字的函数会报错，这时候用一个括号把它包起来就不会报错了,然后在最后面加一个括号就可以马上执行这个函数了—— <strong>直接调用</strong> ，也叫 <strong>自执行函数</strong> 。</p>
<p><strong>作用</strong> ： 避免多人开发时变量冲突，自执行函数只能调用一次。</p>
<pre class='hljs'><code><div><span class="hljs-comment">//参数直接写在括号里</span>
<span class="hljs-comment">//写法1</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sum</span>)</span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;JavaScript&quot;</span>+sum);
})(<span class="hljs-string">&quot;你好&quot;</span>)
<span class="hljs-comment">//输出内容为  JavaScript你好</span>

<span class="hljs-comment">//写法2</span>
~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;立即执行匿名函数！&#x27;</span>)
}()

<span class="hljs-comment">//写法3</span>
!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;立即执行匿名函数！&#x27;</span>);
}()
</div></code></pre>
<h4 id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%88%E8%B7%9Flambda%E7%9B%B8%E4%BC%BC%EF%BC%89" tabindex="-1">箭头函数（跟lambda相似）</h4>
<p>箭头函数表面上相当于匿名函数，并且简化了函数定义。</p>
<pre class='hljs'><code><div>(x,y) =&gt; {
	<span class="hljs-keyword">return</span> x + y;
}
</div></code></pre>
<h3 id="%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" tabindex="-1">函数参数</h3>
<p>JavaScript 函数对参数的值没有进行任何的检查。</p>
<h4 id="%E5%87%BD%E6%95%B0%E6%98%BE%E5%BC%8F%E5%8F%82%E6%95%B0(parameters)%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0(arguments)" tabindex="-1">函数显式参数(Parameters)和隐式参数(Arguments)</h4>
<p>函数显式参数在函数定义时列出。</p>
<p>函数隐式参数在函数调用时传递给函数真正的值。</p>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Name</span>(<span class="hljs-params">parameter1, parameter2, parameter3</span>) </span>{
    <span class="hljs-comment">// 要执行的代码……</span>
}
</div></code></pre>
<h4 id="%E5%8F%82%E6%95%B0%E8%A7%84%E5%88%99" tabindex="-1">参数规则</h4>
<p>JavaScript 函数定义显式参数时没有指定数据类型。</p>
<p>JavaScript 函数对隐式参数没有进行类型检测。</p>
<p>JavaScript 函数对隐式参数的个数没有进行检测。</p>
<h4 id="%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0" tabindex="-1">默认参数</h4>
<p>ES5 中如果函数在调用时未提供隐式参数，参数会默认设置为： <strong>undefined</strong></p>
<p>有时这是可以接受的，但是建议最好为参数设置一个默认值：</p>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">x, y</span>) </span>{
    y = y || <span class="hljs-number">0</span>;
}
<span class="hljs-comment">//如果 y 已经定义，y || 0 返回 y，因为 y 是 true，否则返回 0，因为 undefined 为 false。</span>
</div></code></pre>
<h4 id="es6-%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B8%A6%E5%8F%82%E6%95%B0" tabindex="-1">ES6 函数可以自带参数</h4>
<p>ES6 支持函数带有默认参数，就判断 undefined 和 || 的操作：</p>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">x, y = <span class="hljs-number">10</span></span>) </span>{
    <span class="hljs-comment">// y is 10 if not passed or undefined</span>
    <span class="hljs-keyword">return</span> x + y;
}
 
myFunction(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 输出 2</span>
myFunction(<span class="hljs-number">5</span>); <span class="hljs-comment">// 输出 15, y 参数的默认值</span>
</div></code></pre>
<h4 id="arguments-%E5%AF%B9%E8%B1%A1" tabindex="-1">arguments 对象</h4>
<p>JavaScript 函数有个内置的对象 arguments 对象。</p>
<p>arguments 对象包含了函数调用的参数数组。</p>
<p>通过这种方式你可以很方便的找到最大的一个参数的值：</p>
<pre class='hljs'><code><div>x = sumAll(<span class="hljs-number">1</span>, <span class="hljs-number">123</span>, <span class="hljs-number">500</span>, <span class="hljs-number">115</span>, <span class="hljs-number">44</span>, <span class="hljs-number">88</span>);
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sumAll</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> i, sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
        sum += <span class="hljs-built_in">arguments</span>[i];
    }
    <span class="hljs-keyword">return</span> sum;
}
</div></code></pre>
<h4 id="%E9%80%9A%E8%BF%87%E5%80%BC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89" tabindex="-1">通过值传递参数（基本数据类型）</h4>
<p>在函数中调用的参数是函数的隐式参数。</p>
<p>JavaScript 隐式参数通过值来传递：函数仅仅只是获取值。</p>
<p>如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）。</p>
<p>隐式参数的改变在函数外是不可见的。</p>
<h4 id="%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89" tabindex="-1">通过对象传递参数（地址）</h4>
<p>在JavaScript中，可以引用对象的值。</p>
<p>因此我们在函数内部修改对象的属性就会修改其初始的值。</p>
<p>修改对象属性可作用于函数外部（全局变量）。</p>
<p>修改对象属性在函数外是可见的。</p>
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E8%BD%BD%3F" tabindex="-1">什么是重载?</h3>
<p>相同函数名，不同形参列表的多个函数，可以在调用时根据传入的实参值的不同，执行不同的逻辑。</p>
<p>好处：减少函数名的个数，减轻调用者的负担</p>
<p>但在JS当中，函数的名字不能重名，当函数重名的时候，后声明的函数会将之前声明的同名函数覆盖，无法像java一样进行直接重载</p>
<h4 id="%E7%AC%AC%E4%B8%80%E7%A7%8D%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0" tabindex="-1">第一种重载实现</h4>
<p>这种方法比较简单，给一个思路，大家肯定都能理解，就是函数内部用if或switch语句，根据传入参数的个数调用不同的case语句，从而功能上达到重载的效果。</p>
<pre class='hljs'><code><div>&lt;script language=<span class="hljs-string">&quot;JavaScript&quot;</span>&gt; 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">length,width</span>) 
</span>{ 
    <span class="hljs-keyword">var</span> len= <span class="hljs-built_in">arguments</span>.length; 
    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>== len) 
    { 
        <span class="hljs-keyword">var</span> width = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]; 
        alert(<span class="hljs-string">&quot;高为：&quot;</span>+length+<span class="hljs-string">&quot;，宽为：&quot;</span>+width); 
    } 
    <span class="hljs-keyword">else</span> 
    { 
        alert(<span class="hljs-string">&quot;高为：&quot;</span>+length); 
    } 
} 
&lt;/srcipt&gt;

</div></code></pre>
<p>这种方法简单粗暴。但是对于一个正在学习js的人来说，这种方法未免太敷衍了。</p>
<h4 id="%E7%AC%AC%E4%BA%8C%E7%A7%8D%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0" tabindex="-1">第二种重载实现</h4>
<p>是第一种方法的增强</p>
<p>addMethod方法用来给一个对象添加自定义方法，能够接收三个参数：</p>
<ol>
<li>需要添加方法的对象</li>
<li>自定义方法名</li>
<li>定义方法具体要实现的功能，通过回调实现</li>
</ol>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addMethod</span>(<span class="hljs-params">object, name, fn</span>) </span>{
        <span class="hljs-keyword">var</span> old = object[name];
        object[name] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
          <span class="hljs-built_in">console</span>.log(fn.length);
          <span class="hljs-keyword">if</span> (fn.length === <span class="hljs-built_in">arguments</span>.length) {
            <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> old === <span class="hljs-string">&quot;function&quot;</span>) {
            <span class="hljs-keyword">return</span> old.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);
          }
        }
        <span class="hljs-built_in">console</span>.log(object[name]);
      }


      <span class="hljs-keyword">var</span> people = {
        <span class="hljs-attr">values</span>: [<span class="hljs-string">&quot;Dean Edwards&quot;</span>, <span class="hljs-string">&quot;Alex Russell&quot;</span>, <span class="hljs-string">&quot;Dean Tom&quot;</span>]
      };

      <span class="hljs-comment">/* 下面开始通过addMethod来实现对people.find方法的重载 */</span>

      <span class="hljs-comment">// 不传参数时，返回peopld.values里面的所有元素</span>
      addMethod(people, <span class="hljs-string">&quot;find&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.values;
      });

      <span class="hljs-comment">// 传一个参数时，按first-name的匹配进行返回</span>
      addMethod(people, <span class="hljs-string">&quot;find&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">firstName</span>) </span>{
        <span class="hljs-keyword">var</span> ret = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.values.length; i++) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.values[i].indexOf(firstName) === <span class="hljs-number">0</span>) {
            ret.push(<span class="hljs-built_in">this</span>.values[i]);
          }
        }
        <span class="hljs-keyword">return</span> ret;
      });

      <span class="hljs-comment">// 传两个参数时，返回first-name和last-name都匹配的元素</span>
      addMethod(people, <span class="hljs-string">&quot;find&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">firstName, lastName</span>) </span>{
        <span class="hljs-keyword">var</span> ret = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.values.length; i++) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.values[i] === (firstName + <span class="hljs-string">&quot; &quot;</span> + lastName)) {
            ret.push(<span class="hljs-built_in">this</span>.values[i]);
          }
        }
        <span class="hljs-keyword">return</span> ret;
      });

      <span class="hljs-comment">// 测试：</span>
      <span class="hljs-built_in">console</span>.log(people.find()); <span class="hljs-comment">//[&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]</span>
      <span class="hljs-built_in">console</span>.log(people.find(<span class="hljs-string">&quot;Dean&quot;</span>)); <span class="hljs-comment">//[&quot;Dean Edwards&quot;, &quot;Dean Tom&quot;]</span>
      <span class="hljs-built_in">console</span>.log(people.find(<span class="hljs-string">&quot;Dean&quot;</span>, <span class="hljs-string">&quot;Edwards&quot;</span>)); <span class="hljs-comment">//[&quot;Dean Edwards&quot;]*/</span>
</div></code></pre>
<h2 id="%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" tabindex="-1">全局变量和局部变量</h2>
<ul>
<li>在函数体之外声明的变量属于全局变量；在函数体当中声明的变量，包括一个函数的形参都属于局部变量</li>
<li>全局变量的生命周期是浏览器打开时声明，浏览器关闭时销毁，尽量少用。因为全局变量会一直在浏览器的内存当中，耗费内存空间</li>
<li>局部变量的生命周期是：函数开始执行时局部变量的内存空间开辟，函数执行结束之后，局部变量的内存空间释放，局部变量生命周期较短</li>
</ul>
<pre class='hljs'><code><div><span class="hljs-comment">// 全局变量</span>
<span class="hljs-keyword">var</span> username = <span class="hljs-string">&quot;jack&quot;</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accessUsername</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-comment">// 局部变量</span>
 <span class="hljs-keyword">var</span> username = <span class="hljs-string">&quot;lisi&quot;</span>;
<span class="hljs-comment">// 就近原则:访问局部变量</span>
 alert(<span class="hljs-string">&quot;username = &quot;</span> + username);
 }
 <span class="hljs-comment">// 调用函数</span>
 accessUsername();
<span class="hljs-comment">// 访问全局变量</span>
 alert(<span class="hljs-string">&quot;username = &quot;</span> + username);

</div></code></pre>
<p>先输出lisi后输出jack
因为局部变量结束后便释放了，所以局部变量没有值
而如果单纯没有定义全局变量，全在全局中输出局部变量那会报错</p>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accessAge</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>;
alert(<span class="hljs-string">&quot;年龄 = &quot;</span> + age);
}
		   
accessAge();
		   
<span class="hljs-comment">// 报错(语法不对)</span>
 alert(<span class="hljs-string">&quot;age = &quot;</span> + age);

</div></code></pre>
<p>如果一个变量在声明的时候没有定义var，默认是全局变量（即使在局部变量中声明）</p>
<pre class='hljs'><code><div><span class="hljs-comment">// 以下语法是很奇怪的.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myfun</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-comment">// 当一个变量声明的时候没有使用var关键字,那么不管这个变量是在哪里声明的,都是全局变量.</span>
myname = <span class="hljs-string">&quot;dujubin&quot;</span>;
 }
		   
<span class="hljs-comment">// 访问函数</span>
myfun();
		   
alert(<span class="hljs-string">&quot;myname = &quot;</span> + myname); <span class="hljs-comment">// myname = dujubin</span>

</div></code></pre>
<p><strong>JavaScript 没有块级作用域（ES6 之前）。</strong></p>
<p>在 ES6 之前，是没有块级作用域的概念的。ES6 可以使用 let 关键字来实现块级作用域。</p>
<p>这一点也是JavaScript相比其它语言较灵活的部分。仔细观察下面的代码，你会发现变量i、j、k作用域是相同的，他们在整个rain函数体内都是全局的。</p>
<p>对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境中。而对于JavaScript来说，for语句创建的变量 i 即使在for循环执行结束之后，依旧存在于循环外部的执行环境之中。</p>
<pre class='hljs'><code><div>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rainman</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// rainman函数体内存在三个局部变量 i j k</span>
        <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> ( <span class="hljs-number">1</span> ) {
            <span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) {
                alert( k );    <span class="hljs-comment">//分别弹出 0 1 2</span>
            }
            alert( k );        <span class="hljs-comment">//弹出3</span>
        }
        alert( j );            <span class="hljs-comment">//弹出0</span>
    }
&lt;/script&gt;

</div></code></pre>
<h2 id="var%E3%80%81let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB" tabindex="-1">var、let和const的区别</h2>
<ol>
<li>使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；</li>
<li>使用let声明的变量，其作用域为该语句所在的代码块（所在花括号里）内，不存在变量提升；</li>
<li>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改：</li>
<li>let不允许在相同作用域内重复声明同一个变量。</li>
<li>const定义常量（必须初始化）与使用 let 定义的变量相似：二者都是块级作用域，都不能和它所在作用域内的其他变量或函数拥有相同的名称</li>
<li>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。</li>
</ol>
<p>经典案例</p>
<pre class='hljs'><code><div>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;
        <span class="hljs-comment">//试验代码</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++){
            <span class="hljs-built_in">console</span>.log(i);
        }
        <span class="hljs-built_in">console</span>.log(i);
    &lt;/script&gt;
<span class="hljs-comment">//0 1 2 3 4 5 </span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">//试验代码</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++){
            <span class="hljs-built_in">console</span>.log(i);
        }
        <span class="hljs-built_in">console</span>.log(i);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
//报错

const cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];
cars = [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;Audi&quot;];    // 错误

// 创建常量对象
const car = {type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;};
// 修改属性:
car.color = &quot;red&quot;;
// 添加属性
car.owner = &quot;Johnson&quot;;
</span></div></code></pre>
<h2 id="%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">运算符</h2>
<h3 id="%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">逗号运算符</h3>
<p>使用逗号可以在一条语句中执行多次操作</p>
<p>使用逗号运算符分隔的语句会 从左到右 依次执行</p>
<pre class='hljs'><code><div><span class="hljs-keyword">var</span> age1=<span class="hljs-number">16</span>,age2=<span class="hljs-number">17</span>,age3=<span class="hljs-number">18</span>;
</div></code></pre>
<h3 id="%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">算术运算符</h3>
<pre class='hljs'><code><div> + -	*	/	%	++	--

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
 
    alert(<span class="hljs-number">1234</span> / <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>); <span class="hljs-comment">// 1234</span>
  
    <span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;12&quot;</span>;
     s -= <span class="hljs-number">10</span>;
    alert(s);  <span class="hljs-comment">// 2</span>
 
    <span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;aa&quot;</span>;
    s -= <span class="hljs-number">10</span>;
    alert(s);  <span class="hljs-comment">// NaN       Not a Number 不是一个数字</span>
 
    <span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;12&quot;</span>;
    s += <span class="hljs-number">10</span>;
    alert(s);       <span class="hljs-comment">// 1210 </span>
 
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

注意： 
- js中的小数和整数都是number类型，不存在整数除以整数还是整数的结论。
 - 字符串和其他的数据使用+号运算，会连接成一个新的字符串。
 - 字符串使用除了+以外的运算符：如果字符串本身是一个数字，那么会自动转成number进行运算，
否则就会返回一个<span class="hljs-literal">NaN</span>的结果，表示这不是一个数字。<span class="hljs-literal">NaN</span>：not a number

</div></code></pre>
<h3 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">关系运算符</h3>
<pre class='hljs'><code><div>&gt;		&gt;=		&lt;		&lt;=  	!=

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
 
    <span class="hljs-comment">// 请问: 2 &gt; 5, 结果为 ?</span>
    alert(<span class="hljs-number">2</span> &gt; <span class="hljs-number">5</span>);   <span class="hljs-comment">// false</span>
 
    <span class="hljs-comment">// 请问: “22” == 22  结果为 ?</span>
    alert(<span class="hljs-string">&quot;22&quot;</span> == <span class="hljs-number">22</span>); <span class="hljs-comment">// true  (仅仅判断数值)</span>
 
    <span class="hljs-comment">// 请问: “22” === 22  结果为 ?</span>
    alert(<span class="hljs-string">&quot;22&quot;</span> === <span class="hljs-number">22</span>);  <span class="hljs-comment">// false  (恒等于, 数值和类型都要相等)</span>
  
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</div></code></pre>
<h3 id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">逻辑运算符</h3>
<pre class='hljs'><code><div>&amp;&amp;	 	逻辑与		<span class="hljs-literal">true</span>&amp;&amp;<span class="hljs-literal">false</span>		====&gt;<span class="hljs-literal">false</span>
|| 		逻辑或		<span class="hljs-literal">true</span>||<span class="hljs-literal">false</span>		====&gt;<span class="hljs-literal">true</span>
！ 		逻辑非		!<span class="hljs-literal">true</span>			====&gt;<span class="hljs-literal">false</span>

针对 &amp;&amp; : 有一个假即为假。
针对 || : 有一个真即为真。

<span class="hljs-literal">true</span>（理解）： <span class="hljs-literal">true</span>,  非<span class="hljs-number">0</span>,  非<span class="hljs-literal">null</span>,  非<span class="hljs-literal">undefined</span>
<span class="hljs-literal">false</span>（理解）：<span class="hljs-literal">false</span>,  <span class="hljs-number">0</span>,   <span class="hljs-literal">null</span>,    <span class="hljs-literal">undefined</span> 

&lt;script&gt;
    <span class="hljs-comment">// 请问 1:  8 &lt; 7 &amp;&amp; 3 &lt; 4,结果为 ?</span>
    alert(<span class="hljs-number">8</span> &lt; <span class="hljs-number">7</span> &amp;&amp; <span class="hljs-number">3</span> &lt; <span class="hljs-number">4</span>);  <span class="hljs-comment">// false</span>
 
    <span class="hljs-comment">// 请问 2:  -2 &amp;&amp; 6 + 6 &amp;&amp; null 结果为 ?</span>
    alert(-<span class="hljs-number">2</span> &amp;&amp; <span class="hljs-number">6</span> + <span class="hljs-number">6</span> &amp;&amp; <span class="hljs-literal">null</span>); <span class="hljs-comment">// null</span>
 
    <span class="hljs-comment">// 请问 3:  1 + 1 &amp;&amp; 0 &amp;&amp; 5  结果为 ?</span>
    alert(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">5</span>); <span class="hljs-comment">// 0</span>
 
    <span class="hljs-comment">// 请问1 :  0 || 23 结果为 ?</span>
    alert(<span class="hljs-number">0</span> || <span class="hljs-number">23</span>); <span class="hljs-comment">// 23</span>
 
    <span class="hljs-comment">// 请问2 :  0 || false || true  结果为 ?</span>
    alert(<span class="hljs-number">0</span> || <span class="hljs-literal">false</span> || <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span>
 
    <span class="hljs-comment">// 请问3 :  null || 10 &lt; 8 || 10 + 10 结果为 ?</span>
    alert(<span class="hljs-literal">null</span> || <span class="hljs-number">10</span> &lt; <span class="hljs-number">8</span> || <span class="hljs-number">10</span> + <span class="hljs-number">10</span>);  <span class="hljs-comment">// 20</span>
 
    <span class="hljs-comment">// 请问4 :  null || 10 &lt; 8 || false 结果为 ?</span>
    alert(<span class="hljs-literal">null</span> || <span class="hljs-number">10</span> &lt; <span class="hljs-number">8</span> || <span class="hljs-literal">false</span>); <span class="hljs-comment">// false </span>
  
&lt;/script&gt;
</div></code></pre>
<h3 id="%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">三目运算符</h3>
<pre class='hljs'><code><div>条件?表达式<span class="hljs-number">1</span>:表达式=<span class="hljs-number">2</span> 
如果条件为<span class="hljs-literal">true</span>，返回表达式<span class="hljs-number">1</span>的结果
如果条件为<span class="hljs-literal">false</span>，返回表达式<span class="hljs-number">2</span>的结果
&lt;script&gt;
    <span class="hljs-comment">// 请问1 :  var score=80 &gt;= 60 ? &quot;合格&quot; : &quot;不合格&quot;  结果为 ?</span>
    alert(<span class="hljs-keyword">var</span> score=<span class="hljs-number">80</span> &gt;= <span class="hljs-number">60</span> ? <span class="hljs-string">&quot;合格&quot;</span> : <span class="hljs-string">&quot;不合格&quot;</span>);  <span class="hljs-comment">// 合格</span>
  
    <span class="hljs-comment">// 请问2 :  1 &gt; 5 ? &quot;是的&quot; : &quot;不是&quot; 结果为 ?</span>
    alert(<span class="hljs-number">1</span> &gt; <span class="hljs-number">5</span> ? <span class="hljs-string">&quot;是的&quot;</span> : <span class="hljs-string">&quot;不是&quot;</span>);       <span class="hljs-comment">// 不是</span>
&lt;/script&gt;
</div></code></pre>
<h3 id="%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">赋值运算符</h3>
<pre class='hljs'><code><div>运算符    x=<span class="hljs-number">10</span> y=<span class="hljs-number">5</span>      结果
=	    x=y		        x=<span class="hljs-number">5</span>
+=	   x+=y	   x=x+y	x=<span class="hljs-number">15</span>
-=	   x-=y	   x=x-y	x=<span class="hljs-number">5</span>
*=	   x*=y	   x=x*y	x=<span class="hljs-number">50</span>
/=	   x/=y	   x=x/y	x=<span class="hljs-number">2</span>
%=	   x%=y	   x=x%y	x=<span class="hljs-number">0</span>

</div></code></pre>
<h3 id="void%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1"><strong>void运算符</strong></h3>
<p><strong>立即调用的函数表达式</strong></p>
<pre class='hljs'><code><div><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>)
}()
</div></code></pre>
<p><strong>在a链接中阻止跳转</strong></p>
<pre class='hljs'><code><div>&lt;a href=<span class="hljs-string">&quot;javascript:void(0);&quot;</span>&gt;&lt;/a&gt; 
</div></code></pre>
<p>void(0)会返回undefined，这个链接点击之后不会做任何事情，此时就 禁止了页面跳转。但是这样不是所有浏览器都兼容的，很多时候我们用 href=&quot;#&quot;</p>
<p>两者都是阻止页面跳转，href=&quot;#&quot;执行的时候会在地址栏后面添加#号，还会让页面的滚动条滚动到 页面的最上面。</p>
<p>注意：利用 javascript: 伪协议来执行js代码是不推荐的，利用 href=&quot;#&quot;也有地址栏添加 <code>#号</code>的问题，推荐的做法是为链接元素 绑定事件。</p>
<p><strong>在箭头函数中</strong></p>
<p>箭头函数标准中，当函数返回值是一个不会被使用到的时候，应该使用 void运算符，来确保返回 undefined。</p>
<pre class='hljs'><code><div><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span> doSomething();
</div></code></pre>
<p><strong>判断值是否为undefined中</strong></p>
<p>在实际开发中，我们判断一个值为 undefined的时候，会第一时间想到 txt === undefined的例子，但是这样做其实是有bug的，如果一个全局变量也叫 undefined，那么此时会发生判断错误，正确的写法应该是 txt === void(0)</p>
<pre class='hljs'><code><div><span class="hljs-keyword">if</span>(txt === <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">if</span>(txt === <span class="hljs-keyword">void</span>(<span class="hljs-number">0</span>))
</div></code></pre>
<h2 id="%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5" tabindex="-1">控制语句</h2>
<p>与java结构一致，不赘述了</p>
<h2 id="js%E4%BA%8B%E4%BB%B6" tabindex="-1">js事件</h2>
<h3 id="%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6" tabindex="-1">常用事件</h3>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onchange</td>
<td>HTML 元素改变</td>
</tr>
<tr>
<td>onclick</td>
<td>用户点击 HTML 元素</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标指针移动到指定的元素上时发生</td>
</tr>
<tr>
<td>onmouseout</td>
<td>用户从一个 HTML 元素上移开鼠标时发生</td>
</tr>
<tr>
<td>onkeydown</td>
<td>用户按下键盘按键</td>
</tr>
<tr>
<td>onload</td>
<td>浏览器已完成页面的加载</td>
</tr>
</tbody>
</table>
<h3 id="%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E6%96%B9%E5%BC%8F" tabindex="-1">注册事件方式</h3>
<p>回调函数的特点:由其他程序负责调用该函数</p>
<p><strong>第一种注册方式</strong> ：直接在标签中使用事件句柄</p>
<pre class='hljs'><code><div>&lt;script&gt;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>)</span>{
   alert(<span class="hljs-string">&quot;hello js!&quot;</span>);
}
&lt;/script&gt;

&lt;!--以下代码的含义是：将sayHello函数注册到按钮上，等待click事件发生之后，该函数被浏览器调用。我们称这个函数为回调函数。--&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;sayHello()&quot;</span>/&gt;</span></span>

</div></code></pre>
<p><strong>第二种注册方式</strong> ：使用js代码完成事件注册</p>
<pre class='hljs'><code><div>&lt;input type=<span class="hljs-string">&quot;button&quot;</span> value=<span class="hljs-string">&quot;hello4&quot;</span> id=<span class="hljs-string">&quot;mybtn2&quot;</span> /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">
	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSome</span>(<span class="hljs-params"></span>)</span>{
		alert(<span class="hljs-string">&quot;do some!&quot;</span>);
	}
 <span class="hljs-comment">// 第一步:先获取这个按钮对象(document是全部小写，内置对象，可以直接用，document就代表整个HTML页面)</span>
<span class="hljs-keyword">var</span> btnObj = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mybtn&quot;</span>);
<span class="hljs-comment">// 第二步:给按钮对象的onclick属性赋值</span>
btnObj.onclick = doSome; <span class="hljs-comment">// 注意:别加小括号. btnObj.onclick = doSome();这是错误的写法.</span>
<span class="hljs-comment">// 这行代码的含义是,将回调函数doSome注册到click事件上.</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

</div></code></pre>
<p><strong>第三种注册方式</strong> ：使用匿名函数（非必须，期望使用前两种）</p>
<pre class='hljs'><code><div><span class="hljs-keyword">var</span> mybtn1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mybtn&quot;</span>);
mybtn1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-comment">// 匿名函数,这个匿名函数也是一个回调函数.</span>
   alert(<span class="hljs-string">&quot;test..........&quot;</span>); <span class="hljs-comment">// 这个函数在页面打开的时候只是注册上,不会被调用,在click事件发生之后才会调用.</span>
}
</div></code></pre>
<h3 id="%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" tabindex="-1">代码执行顺序</h3>
<pre class='hljs'><code><div>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;

<span class="hljs-comment">// 第一步:根据id获取节点对象</span>
<span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>); <span class="hljs-comment">// 返回null(因为代码执行到此处的时候id=&quot;btn&quot;的元素还没有加载到内存)</span>

<span class="hljs-comment">// 第二步:给节点对象绑定事件</span>
btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
	alert(<span class="hljs-string">&quot;hello js&quot;</span>);
}


		   
&lt;/script&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> /&gt;</span></span>

</div></code></pre>
<p>执行错误，返回了null，因为还未获取到id元素，但将顺序反过来偶尔会忘记，所以我们添加上面的一个函数load()，页面加载完的时候才会发生</p>
<pre class='hljs'><code><div>&lt;script&gt;
<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;id属性&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
		<span class="hljs-comment">//获得属性后的 利用属性执行函数</span>
	}
}
&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;框中的值&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id属性&quot;</span> /&gt;</span></span>

</div></code></pre>
<h3 id="%E8%AE%BE%E7%BD%AE%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7" tabindex="-1">设置节点的属性</h3>
<p>通过点击一个按钮狂，将其变为复选框</p>
<pre class='hljs'><code><div>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;
	<span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
		<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
			<span class="hljs-keyword">var</span> mytext = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mytext&quot;</span>);
			<span class="hljs-comment">// 一个节点对象中只要有的属性都可以&quot;.&quot;</span>
			mytext.type = <span class="hljs-string">&quot;checkbox&quot;</span>;
		}
	}
&lt;/script&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mytext&quot;</span>/&gt;</span></span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;将文本框修改为复选框&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>/&gt;</span></span>

</div></code></pre>
<h3 id="%E6%8D%95%E6%8D%89%E5%9B%9E%E8%BD%A6%E9%94%AE" tabindex="-1">捕捉回车键</h3>
<p>回车键的键值是13、ESC键的键值是27，按钮键是onclick，而回车键onkeydown，回调函数的参数可以有，有与没有都会调用回调函数</p>
<pre class='hljs'><code><div><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mytext&quot;</span>&gt;</span>
 
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">
    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mytext&quot;</span>).onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>)</span>{
            <span class="hljs-keyword">if</span> (event.keyCode == <span class="hljs-number">13</span>)
            alert(<span class="hljs-string">&quot;点击了回车！&quot;</span>);
        }
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<h2 id="%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F" tabindex="-1">严格模式</h2>
<p>JavaScript 严格模式（strict mode）即在严格的条件下运行（严格遵守语法规则）。</p>
<p>严格模式下你不能使用未声明的变量。</p>
<p>严格模式通过在脚本或函数的头部添加 <strong>use strict</strong>; 表达式来声明。</p>
<pre class='hljs'><code><div>x = <span class="hljs-number">3.14</span>;       <span class="hljs-comment">// 不报错</span>
myFunction();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">   &quot;use strict&quot;</span>;
    y = <span class="hljs-number">3.14</span>;   <span class="hljs-comment">// 报错 (y 未定义)</span>
}
</div></code></pre>
<h2 id="js-%E8%A1%A8%E5%8D%95" tabindex="-1">js 表单</h2>
<p>HTML 表单验证可以通过 JavaScript 来完成。</p>
<p>以下实例代码用于判断表单字段(fname)值是否存在， 如果不存在，就弹出信息，阻止表单提交：</p>
<pre class='hljs'><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateForm</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> x = <span class="hljs-built_in">document</span>.forms[<span class="hljs-string">&quot;myForm&quot;</span>][<span class="hljs-string">&quot;fname&quot;</span>].value;
    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || x == <span class="hljs-string">&quot;&quot;</span>) {
        alert(<span class="hljs-string">&quot;需要输入名字。&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myForm&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo_form.php&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return validateForm()&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>
名字: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>disabled</td>
<td>规定输入的元素不可用</td>
</tr>
<tr>
<td>max</td>
<td>规定输入元素的最大值</td>
</tr>
<tr>
<td>min</td>
<td>规定输入元素的最小值</td>
</tr>
<tr>
<td>pattern</td>
<td>规定输入元素值的模式（正则表达式）</td>
</tr>
<tr>
<td>required</td>
<td>规定输入元素字段是必需的</td>
</tr>
<tr>
<td>type</td>
<td>规定输入元素的类型</td>
</tr>
</tbody>
</table>
<h2 id="this" tabindex="-1">this</h2>
<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<h3 id="%E5%90%8C%E5%90%8D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F" tabindex="-1">同名全局变量和局部变量</h3>
<p>出现同名全局变量和局部变量时，调用全局变量，需要将全局this赋给this_(重命名)，在局部使用this_调用即可</p>
<pre class='hljs'><code><div>&lt;script&gt;
<span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&quot;Doe123&quot;</span>;
this_ = <span class="hljs-built_in">this</span>
<span class="hljs-comment">// 创建一个对象</span>
<span class="hljs-keyword">var</span> person = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">lastName</span> : <span class="hljs-string">&quot;Doe&quot;</span>,
  <span class="hljs-attr">id</span>     : <span class="hljs-number">5566</span>,
  <span class="hljs-attr">fullName</span> : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + this_.lastName;
  }
};

<span class="hljs-comment">// 显示对象的数据</span>
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = person.fullName();
&lt;/script&gt;
</div></code></pre>
<h3 id="%E4%BA%8B%E4%BB%B6%E4%B8%AD%E7%9A%84this" tabindex="-1">事件中的this</h3>
<pre class='hljs'><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;this.style.display=&#x27;none&#x27;&quot;</span>&gt;</span>点我后我就消失了<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<h3 id="%E6%98%BE%E5%BC%8F%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A" tabindex="-1">显式函数绑定</h3>
<p>在 JavaScript 中函数也是对象，对象则有方法，apply （参数为数组）和 call（参数为列表项） 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。（将一个对象的方法，提供给其他对象使用）</p>
<p>在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, <strong>this</strong> 将指向 person2, 即便它是 person1 的方法：</p>
<pre class='hljs'><code><div><span class="hljs-keyword">var</span> person1 = {
  <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName;
  }
}
<span class="hljs-keyword">var</span> person2 = {
  <span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;John&quot;</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;Doe&quot;</span>,
}
person1.fullName.call(person2);  <span class="hljs-comment">// 返回 &quot;John Doe&quot;</span>
</div></code></pre>
<h2 id="js%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B" tabindex="-1">js异步编程</h2>
<p>在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。</p>
<p>现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。</p>
<p>为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p>
<h3 id="%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" tabindex="-1">回调函数</h3>
<p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p>
<pre class='hljs'><code><div><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML=<span class="hljs-string">&quot;RUNOOB!&quot;</span>;
}, <span class="hljs-number">3000</span>);
</div></code></pre>
<p>这段程序中的 setTimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 &quot;print&quot;，在命令行输出 &quot;RUNOOB!&quot;。</p>
<h3 id="%E5%BC%82%E6%AD%A5-ajax" tabindex="-1">异步 AJAX</h3>
<p>除了 setTimeout 函数以外，异步回调广泛应用于 AJAX 编程。（简单演示）</p>
<pre class='hljs'><code><div><span class="hljs-comment">//js</span>
<span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
 
xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 输出接收到的文字数据</span>
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML=xhr.responseText;
}
 
xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML=<span class="hljs-string">&quot;请求出错&quot;</span>;
}
 
<span class="hljs-comment">// 发送异步 GET 请求</span>
xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.runoob.com/try/ajax/ajax_info.txt&quot;</span>, <span class="hljs-literal">true</span>);
xhr.send();

<span class="hljs-comment">//使用jq库</span>
$.get(<span class="hljs-string">&quot;https://www.runoob.com/try/ajax/demo_test.php&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data,status</span>)</span>{
    alert(<span class="hljs-string">&quot;数据: &quot;</span> + data + <span class="hljs-string">&quot;\n状态: &quot;</span> + status);
});
</div></code></pre>
<h2 id="js-promise" tabindex="-1">JS Promise</h2>
<p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p>
<h3 id="%E6%9E%84%E9%80%A0-promise" tabindex="-1">构造 Promise</h3>
<p>现在我们新建一个 Promise 对象：</p>
<pre class='hljs'><code><div><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-comment">// 要做的事情...</span>
});
</div></code></pre>
<p>如果我想分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒：</p>
<h3 id="%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%86%99%E6%B3%95" tabindex="-1">失败的写法</h3>
<pre class='hljs'><code><div><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;First&quot;</span>);
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Second&quot;</span>);
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Third&quot;</span>);
        }, <span class="hljs-number">3000</span>);
    }, <span class="hljs-number">4000</span>);
}, <span class="hljs-number">1000</span>);
</div></code></pre>
<p>这段程序实现了这个功能，但是它是用 &quot;函数瀑布&quot; 来实现的。可想而知，在一个复杂的程序当中，用 &quot;函数瀑布&quot; 实现的程序无论是维护还是异常处理都是一件特别繁琐的事情，而且会让缩进格式变得非常冗赘。</p>
<h3 id="%E6%88%90%E5%8A%9F%E7%9A%84%E5%86%99%E6%B3%95" tabindex="-1">成功的写法</h3>
<pre class='hljs'><code><div><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;First&quot;</span>);
        resolve();
    }, <span class="hljs-number">1000</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Second&quot;</span>);
            resolve();
        }, <span class="hljs-number">4000</span>);
    });
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Third&quot;</span>);
    }, <span class="hljs-number">3000</span>);
});
</div></code></pre>
<h3 id="promise-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" tabindex="-1">Promise 的构造函数</h3>
<p>Promise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数。</p>
<p>Promise 构造函数接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为<strong>起始函数</strong>。起始函数包含两个参数 resolve 和 reject，分别表示 Promise 成功和失败的状态。</p>
<p>起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。</p>
<p>Promise 构造函数返回一个 Promise 对象，该对象具有以下几个方法：</p>
<ul>
<li>then：用于处理 Promise 成功状态的回调函数。</li>
<li>catch：用于处理 Promise 失败状态的回调函数。</li>
<li>finally：无论 Promise 是成功还是失败，都会执行的回调函数。</li>
</ul>
<p>下面是一个使用 Promise 构造函数创建 Promise 对象的例子：</p>
<p>当 Promise 被构造时，起始函数会被同步执行：</p>
<pre class='hljs'><code><div><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) 
	reject(<span class="hljs-string">&quot;Divide zero&quot;</span>);
    <span class="hljs-keyword">else</span> 
	 resolve(a / b);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a / b = &quot;</span> + value);
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-built_in">console</span>.log(err);
}).finally(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;End&quot;</span>);
});
</div></code></pre>
<p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p>
<p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p>
<p>但是请注意以下两点：</p>
<ul>
<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>
<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>
</ul>
<h3 id="promise-%E5%87%BD%E6%95%B0" tabindex="-1">Promise 函数</h3>
<p>上述的 &quot;计时器&quot; 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个 Promise 函数：</p>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">delay, message</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(message);
            resolve();
        }, delay);
    });
}

print(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;First&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> print(<span class="hljs-number">4000</span>, <span class="hljs-string">&quot;Second&quot;</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    print(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;Third&quot;</span>);
});
</div></code></pre>
<h3 id="%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0(async-function)" tabindex="-1">异步函数(async function)</h3>
<pre class='hljs'><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">delay, message</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(message);
            resolve();
        }, delay);
    });
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">await</span> print(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;First&quot;</span>);
    <span class="hljs-keyword">await</span> print(<span class="hljs-number">4000</span>, <span class="hljs-string">&quot;Second&quot;</span>);
    <span class="hljs-keyword">await</span> print(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;Third&quot;</span>);
}
asyncFunc();
</div></code></pre>
<p>异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p>
<p>异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。</p>
<p>带返回值的async await</p>
<pre class='hljs'><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFunc</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(
        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
            resolve(<span class="hljs-string">&quot;Return value&quot;</span>);
        }
    );
    <span class="hljs-built_in">console</span>.log(value);
}
asyncFunc();
</div></code></pre>
<h2 id="%E9%97%AD%E5%8C%85" tabindex="-1">闭包</h2>
<pre class='hljs'><code><div><span class="hljs-keyword">var</span> add = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">return</span> counter += <span class="hljs-number">1</span>;}
})();
 
add();
add();
add();
 
<span class="hljs-comment">// 计数器为 3</span>
</div></code></pre>
<ol>
<li>变量 <strong>add</strong> 指定了函数自我调用的返回字值。</li>
<li>自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。</li>
<li>add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。</li>
<li>这个叫作 JavaScript  <strong>闭包。</strong> 它使得函数拥有私有变量变成可能。</li>
<li>计数器受匿名函数的作用域保护，只能通过 add 方法修改。</li>
</ol>
<h2 id="js-%E7%B1%BB" tabindex="-1">js 类</h2>
<h3 id="%E7%A4%BA%E4%BE%8B" tabindex="-1">示例</h3>
<pre class='hljs'><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runoob</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, year</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.year = year;
  }
  <span class="hljs-function"><span class="hljs-title">age</span>(<span class="hljs-params">x</span>)</span> {
    <span class="hljs-keyword">return</span> x - <span class="hljs-built_in">this</span>.year;
  }
}
 
<span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
<span class="hljs-keyword">let</span> year = date.getFullYear();
 
<span class="hljs-keyword">let</span> runoob = <span class="hljs-keyword">new</span> Runoob(<span class="hljs-string">&quot;菜鸟教程&quot;</span>, <span class="hljs-number">2020</span>);
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML=
<span class="hljs-string">&quot;菜鸟教程 &quot;</span> + runoob.age(year) + <span class="hljs-string">&quot; 岁了。&quot;</span>;
</div></code></pre>
<h3 id="%E7%B1%BB%E6%96%B9%E6%B3%95" tabindex="-1">类方法</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.runoob.com/js/jsref-constructor-class.html">constructor()</a></td>
<td>构造函数，用于创建和初始化类</td>
</tr>
</tbody>
</table>
<h3 id="%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97" tabindex="-1">类关键字</h3>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.runoob.com/js/jsref-class-extends.html">extends</a></td>
<td>继承一个类</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/js/jsref-class-static.html">static</a></td>
<td>在类中定义一个静态方法</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/js/jsref-class-super.html">super</a></td>
<td>调用父类的构造方法</td>
</tr>
</tbody>
</table>
<h3 id="%E7%BB%A7%E6%89%BF" tabindex="-1">继承</h3>
<p><strong>super()</strong> 方法引用父类的构造方法。</p>
<p>通过在构造方法中调用 <strong>super()</strong> 方法，我们调用了父类的构造方法，这样就可以访问父类的属性和方法。</p>
<p>继承对于代码可复用性很有用。</p>
<pre class='hljs'><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Site</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.sitename = name;
  }
  <span class="hljs-function"><span class="hljs-title">present</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我喜欢&#x27;</span> + <span class="hljs-built_in">this</span>.sitename;
  }
}
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runoob</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Site</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> {
    <span class="hljs-built_in">super</span>(name);
    <span class="hljs-built_in">this</span>.age = age;
  }
  <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.present() + <span class="hljs-string">&#x27;, 它创建了 &#x27;</span> + <span class="hljs-built_in">this</span>.age + <span class="hljs-string">&#x27; 年。&#x27;</span>;
  }
}
 
<span class="hljs-keyword">let</span> noob = <span class="hljs-keyword">new</span> Runoob(<span class="hljs-string">&quot;菜鸟教程&quot;</span>, <span class="hljs-number">5</span>);
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = noob.show();
</div></code></pre>
<h3 id="getter-%E5%92%8C-setter" tabindex="-1">getter 和 setter</h3>
<p>类中我们可以使用 getter 和 setter 来获取和设置值，getter 和 setter 都需要在严格模式下执行。getter 和 setter 可以使得我们对属性的操作变的很灵活。类中添加 getter 和 setter 使用的是 get 和 set 关键字。</p>
<p>以下实例为 sitename 属性创建 getter 和 setter：</p>
<pre class='hljs'><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runoob</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.sitename = name;
  }
  <span class="hljs-keyword">get</span> <span class="hljs-title">s_name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sitename;
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title">s_name</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-built_in">this</span>.sitename = x;
  }
}
 
<span class="hljs-keyword">let</span> noob = <span class="hljs-keyword">new</span> Runoob(<span class="hljs-string">&quot;菜鸟教程&quot;</span>);
 
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = noob.s_name;
</div></code></pre>
<h3 id="%E6%8F%90%E5%8D%87" tabindex="-1">提升</h3>
<p>函数声明和类声明之间的一个重要区别在于, 函数声明会提升，类声明不会。</p>
<p>你首先需要声明你的类，然后再访问它，否则代码将抛出 ReferenceError：</p>
<h3 id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95" tabindex="-1">静态方法</h3>
<p>静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 <strong>类名.方法名</strong> 调用静态方法。</p>
<p>静态方法不能在对象上调用，只能在类中调用。</p>
<pre class='hljs'><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runoob</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello!!&quot;</span>;
  }
}
 
<span class="hljs-keyword">let</span> noob = <span class="hljs-keyword">new</span> Runoob(<span class="hljs-string">&quot;菜鸟教程&quot;</span>);
 
<span class="hljs-comment">// 可以在类中调用 &#x27;hello()&#x27; 方法</span>
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = Runoob.hello();
 
<span class="hljs-comment">// 不能通过实例化后的对象调用静态方法</span>
<span class="hljs-comment">// document.getElementById(&quot;demo&quot;).innerHTML = noob.hello();</span>
<span class="hljs-comment">// 以上代码会报错</span>

<span class="hljs-comment">//如果你想在对象 noob 中使用静态方法，可以作为一个参数传递给它：</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runoob</span> </span>{
  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> {
    <span class="hljs-built_in">this</span>.name = name;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params">x</span>)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + x.name;
  }
}
<span class="hljs-keyword">let</span> noob = <span class="hljs-keyword">new</span> Runoob(<span class="hljs-string">&quot;菜鸟教程&quot;</span>);
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;demo&quot;</span>).innerHTML = Runoob.hello(noob);
</div></code></pre>

    </div>
</body>
</html>
