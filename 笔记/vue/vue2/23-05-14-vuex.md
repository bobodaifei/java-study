# Vuex(Vue状态管理模式)

## 介绍

Vue为这些被多个组件频繁使用的值提供了一个统一管理的工具——VueX。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。

了解更多：https://www.jianshu.com/p/2e5973fe1223

## 安装

由于 `VueX`是在学习 `VueCli`后进行的，所以在下文出现的项目的目录请参照 `VueCli 2.x`构建的目录。

以下步骤的前提是你已经完成了Vue项目构建，并且已转至该项目的文件目录下。

```
npm i vuex -s
```

在项目的根目录下新增一个 `store`文件夹，在该文件夹内创建index.js

此时你的项目的 `src`文件夹应当是这样的：

```
│  App.vue
│  main.js
│
├─assets
│      logo.png
│
├─components
│      HelloWorld.vue
│
├─router
│      index.js
│
└─store
       index.js

```

## 简单使用

### 初始化store

```js
import Vue from 'vue'
import Vuex from 'vuex'
 
//挂载Vuex
Vue.use(Vuex)
 
//创建VueX对象
const store = new Vuex.Store({
    state:{
        //存放的键值对就是所要管理的状态
        name:'helloVueX'
    }
})
 
export default store

```

### 挂载main.js

```js
import Vue from 'vue'
import App from './App'
import router from './router'
import store from './store'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  store,  //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中
  render: h => h(App)
})

```

### 组件内调用

在组件中使用Vuex

```html
<template>
    <div id='app'>
        name:
        <h1>{{ $store.state.name }}</h1>
    </div>
</template>

```

或者要在组件方法中使用

```js
...,
methods:{
    add(){
      console.log(this.$store.state.name)
    }
},
...

```

**注意，请不要在此处更改state中的状态的值**

## Vuex和EventBus的区别

 vuex 的底层实现原理其实就是 event-bus，那么它和普通的 event-bus 有什么不同呢？我们通过简单的源码一步步实现来搞懂这个问题。

### **EventBus**

首先一个普通的 event-bus 是这样的：

```js
// main.js
Vue.prototype.$bus = new Vue();

// 组件中
this.$bus.$on('console', (text) => {
    console.log(text);
});

// 组件中
this.$bus.$emit('console', 'hello world');

```

它是通过 Vue 的 $on和 $emit api 来传递消息的。

### **vuex 的响应式数据**

而 vuex 的数据是**响应式**的，那么我们首先实现这种[响应式](https://so.csdn.net/so/search?q=%E5%93%8D%E5%BA%94%E5%BC%8F&spm=1001.2101.3001.7020)数据：

```js
class store {
    constructor(options) {
        this.vm = new Vue({
            data: {
                state: options.state
            },
        });
    }
    get state() {
        return this.vm.state;
    }
}

```

注意，上面的data **不是一个函数** ，因为这里我们只会实例化一次。然后我们通过添加一个 state 的 getter 方法来暴露内部的 event-bus 的 state 属性。

那怎么实现响应式的呢？因为在实例化 vm 的时候，Vue 会自己使用 defineReactive 把 data 变为响应式数据，从而会收集有关它的依赖，然后在自己变动的时候，通知依赖更新。

**加上 getters**

vuex支持加上 getters，怎么加呢？直接初始化一个 getters 属性即可：

```js
class store {
    constructor(options) {
        this.vm = new Vue({
            data: {
                state: options.state
            },
        });
        const getters = options.getter || {};
        this.getters = {};
	//遍历getters的key
        Object.keys(getters).forEach((key) => {
            Object.defineProperty(this.getters, key, () => {
                get: () => getters[key](this.state)
            })
        });
    }

    get state() {
        return this.vm.state;
    }
}
//Object.defineproperty(obj, prop, desc)
//obj :  第一个参数就是要在哪个对象身上添加或者修改属性
//prop : 第二个参数就是添加或修改的属性名
//desc ： 配置项，一般是一个对象
	//writable：	是否可重写
    	//value：  	当前值
    	//get：    	 读取时内部调用的函数
	//set：        写入时内部调用的函数
	//enumerable： 	是否可以遍历
	//configurable： 	是否可再次修改配置项

这段代码是在定义一个`store`类用于管理Vue应用中的数据状态。

1. 在`constructor`函数中，首先使用`Vue`的构造函数创建一个Vue实例对象`vm`，并将`options.state`作为`vm`的初始data，也就是将Vuex中的state数据存储在Vue实例对象`vm`中。

2. 接着，通过`options.getter`获取`getter`，`getter`是一个返回状态值的计算属性，通过对状态进行计算返回新的状态，从而获取派生状态的一种方式。

3. 在后续的代码中，通过对象的方式进行遍历`getters`，将其赋值给`this.getters`，从而实现定义类成员函数。

4. 在`getters`中定义了计算属性，通过`Object.defineProperty`将其设置为只读属性，即只能读取不能修改，通过使用`get`关键字对该函数进行保护。这样，在`store`类中可以调用`this.getters`来获取计算属性的值，并且无法进行修改。

5. 最后，定义了`state`的getter方法，用于返回Vue实例对象`vm`中的数据状态。

这段代码主要实现了以下两个功能：

1. 通过将`state`保存在Vue实例对象中，使得在`store`中调用`state`时，可以获得到数据状态。

2. 通过定义`getter`成员函数以及保护`getter`成员函数的方式，可以避免该计算属性被修改，确保获取计算属性的准确性。
```

原理就是 **添加一个 getters 属性** ，然后遍历 getters 并绑定到它的各个属性的 getter 上面去即可。

**加上 mutations**

类似的，我们可以**添加一个 mutations 属性**来保存 mutations，然后实现一个 commit 方法，在调用 commit 方法的时候去 mutations 里面找，然后调用相应函数即可：






## VueX中的核心内容

在VueX对象中，其实不止有 state,还有用来操作 state中数据的方法集，以及当我们需要对 state中的数据需要加工的方法集等等成员。

成员列表：

* state 存放状态
* mutations state成员操作
* getters 加工state成员给外界
* actions 异步操作
* modules 模块化状态管理
